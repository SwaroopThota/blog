[
	{
		"_id": "621f4dcb91bb3ccf3447c938",
		"title": "Reverse Linkedlist",
		"postLinkTitle": "reverse-linkedlist",
		"desc": "//iterative\r\nNode reverseLinkedList(Node head){\r\n      if(head==null || head.next==null) return head;\r\n      Node prev=null,curr=head,next=null;\r\n      while(curr != null){\r\n                next=curr.next;\r\n                curr.next = prev;\r\n                prev=curr;\r\n                curr = next;\r\n       }\r\n       head = prev;\r\n       return head;\r\n}\r\n//recursive\r\npublic Node reverseList(Node head) {\r\n        if(head == null || head.next ==null) \r\n            return head;\r\n        Node rev = reverseList(head.next); //it returns last node\r\n        head.next.next = head;\r\n        head.next = null;\r\n        return rev;// sends last as it becomes first node in reverse LL\r\n    }\r\n\r\n// Reverse only certain part of linkedlist\r\n// https://leetcode.com/problems/reverse-linked-list-ii/\r\nclass Solution {\r\n    public ListNode reverseBetween(ListNode head, int left, int right) {\r\n        if(head == null || head.next == null) return head;\r\n        ListNode leftEnd = head, rightEnd = head;\r\n        for(int i=1;i<=right;i++){\r\n            // for getting the node before 'left' pos node\r\n            if(i<left-1) leftEnd = leftEnd.next;\r\n            // for getting the node after 'right' pos node\r\n            rightEnd = rightEnd.next;\r\n        }\r\n        // (left == 1) checking if head is included or not\r\n        // if head is included leftEnd is not used\r\n        ListNode revHead = (left == 1) ? head : leftEnd.next;\r\n        ListNode newRevHead = revList(revHead, right-left+1);\r\n       // now revHead will become the last node of reversed part\r\n        // so we'll link it to rightend node\r\n        revHead.next = rightEnd;\r\n        // linking leftEnd to head node of reversed part\r\n        if(left != 1)   leftEnd.next = newRevHead;\r\n        return (left == 1) ? newRevHead : head;\r\n    }\r\n    public ListNode revList(ListNode head,int n){\r\n        ListNode cur = head,prev = null;\r\n        for(int i=1;i<=n;i++){\r\n            ListNode next = cur.next;\r\n            cur.next = prev;\r\n            prev = cur;\r\n            cur = next;\r\n        }\r\n        return prev;\r\n    }\r\n}\r\n// another implementation\r\npublic class Solution {\r\n    ListNode last = null;\r\n    public ListNode reverseBetween(ListNode head, int B, int C) {\r\n        if(head == null || head.next == null) return head;\r\n        int i=1;\r\n        ListNode start = head, prev = null;\r\n        while(i<B){\r\n            prev = start;\r\n            start = start.next;\r\n            i++;\r\n        }\r\n        ListNode rev = revList(start,B,C);\r\n        start.next = last;\r\n        if(prev != null)\r\n            prev.next = rev;\r\n        return prev != null ? head : rev;\r\n    }\r\n    public ListNode revList(ListNode head,int a,int b){\r\n        if(a == b){\r\n            last = head.next;\r\n            return head;\r\n        }\r\n        ListNode rev = revList(head.next,a+1,b);\r\n        head.next.next = head;\r\n        head.next = null;\r\n        return rev;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699802",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c93a",
		"title": "Converting preorder array to BST",
		"postLinkTitle": "converting-preorder-array-to-bst",
		"desc": "//[8,5,1,7,10,12]\r\n//     ^^^   ^^(right sbtr)(>8)\r\n//(8>)left subtre\r\n// and call recursively\r\nclass Solution {\r\n    public TreeNode bstFromPreorder(int[] preorder) {\r\n        return helper(preorder,0,preorder.length-1);\r\n    }\r\n    TreeNode helper(int[] a, int s, int e){\r\n        if(s>e) return null;\r\n        TreeNode root= new TreeNode(a[s]);\r\n        int i=s+1;\r\n        while(i<=e && a[s]>a[i])\r\n            i++;\r\n        root.left = helper(a,s+1,i-1);\r\n        root.right = helper(a,i,e);\r\n        return root;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699810",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c93c",
		"title": "Optimised power function (log(n))",
		"postLinkTitle": "optimised-power-function-log-n",
		"desc": "//x^n\r\nint[] dp;\r\nint calcPower(int x, int n){\r\n       dp= new int[n+1];\r\n       Arrays.fill(d,p-1);\r\n       dp[0]=1; //x^0 = 1\r\n       dp[1]=x; //x^1 = x\r\n       return findPower(x,n);\r\n}\r\nint findPower(int x, int n){\r\n       if(dp[n] != -1) return dp[n];\r\n       if((x&1)==0) return dp[n] = findPower(x,n/2,arr) * findPower(x,n/2,arr);             //n is even so x^n = x^(n/2) * x^(n/2)\r\n       return dp[n] = findPower(x,n/2,arr) * findPower(x,n/2,arr) * x;          //n is odd so x^n = x^(n/2) * x^(n/2) * x\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699812",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c93e",
		"title": "Print all the subsequences or substrings of a string",
		"postLinkTitle": "print-all-the-subsequences-or-substrings-of-a-string",
		"desc": "// printSubstrings(\"abc\",0,\"\");\r\n\r\nvoid printSubstrings(String str, int index, String newString){\r\n        if(index == str.length()){\r\n                     System.out.println(newString+\",\");\r\n                     return;\r\n        }\r\n        //char at index is included\r\n        printSubstring(str, index+1, newString+str.charAt(index));\r\n        //char at index is not included\r\n        printSubstring(str, index+1, newString);\r\n}\r\n/* output:\r\nc,\r\nb,\r\nbc,\r\na,\r\nac,\r\nab,\r\nabc,\r\n,\r\n*/",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699813",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c940",
		"title": "Kadane's Algorithm",
		"postLinkTitle": "kadanes-algorithm",
		"desc": "// Algorithm:\r\n// Initialize:\r\n//     max_so_far = INT_MIN\r\n//     max_ending_here = 0\r\n\r\n// Loop for each element of the array\r\n//   (a) max_ending_here = max_ending_here + a[i]\r\n//   (b) if(max_so_far < max_ending_here)\r\n//             max_so_far = max_ending_here\r\n//   (c) if(max_ending_here < 0)\r\n//             max_ending_here = 0\r\n// return max_so_far\r\n\r\n// code:\r\n int maxSum(int[] arr){\r\n     int currSum = 0,  maxSum = Integer.MIN_VALUE; // if including empty subarray then maxSum =0;\r\n     // here we use the concept of prefix sum. If the prefix sum is less than 0 then we don't\r\n    // forward that sum to next iteration, we start form 0.\r\n    for(int i : arr){\r\n         currSum+=i;\r\n         maxSum = Math.max(maxSum,currSum);\r\n         if(currSum < 0)\r\n         currSum = 0;\r\n    }\r\n    return maxSum;\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699815",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c942",
		"title": "Count possible no. of paths in nxm matrix",
		"postLinkTitle": "count-possible-no-of-paths-in-nxm-matrix",
		"desc": "//We can only move either in right(j+1) direction or down(i+1) direction one step.\r\n//countPaths(0,0,n,m);\r\n\r\nint countPaths(int i, int j, int n, int m){\r\n     if(i == n-1 && j == m-1) return 1;\r\n     int res = 0;\r\n     if(i<n-1) res += countPaths(i+1, j, n, m);\r\n     if(j<m-1) res += countPaths(i, j+1, n, m);\r\n     return res;\r\n}\r\n\r\n//countPaths(0,0,3,3); => 6",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699816",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c944",
		"title": "Order Agnostic Binary search",
		"postLinkTitle": "order-agnostic-binary-search",
		"desc": "orderAgnosticBS(new int[]{1,2,3,4,5,5},3); // 2\r\norderAgnosticBS(new int[]{10,8,7,3,1},3); // 3\r\norderAgnosticBS(new int[]{3,3,3,3,3},3); // 0\r\n\r\n//Works for both asc and desc ordered sequence.\r\nint orderAgnosticBS(int[] arr, int target){\r\n     int start = 0, end = arr.length - 1;\r\n     if(arr[start] < arr[end]){ //asc order\r\n          while(start <= end){\r\n                int mid = start + (end - start) /2; //to prevent overflow\r\n                if(arr[mid] == target) return mid;\r\n                if(arr[mid] > target) end = mid -1;\r\n                else start = mid + 1;\r\n          }\r\n      } else if(arr[start] > arr[end]){ //desc order\r\n          while(start <= end){\r\n                int mid = start + (end - start) /2;\r\n                if(arr[mid] == target) return mid;\r\n                if(arr[mid] > target) start = mid + 1;\r\n                else end = mid -1;\r\n          }\r\n      } else { // all elements in sequence are same\r\n          if(arr[start] == target)\r\n                return start;\r\n      }\r\n      return -1;\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699818",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c946",
		"title": "Recursive Bubble sort",
		"postLinkTitle": "recursive-bubble-sort",
		"desc": "//bubbleSort(arr,0,1,false);\r\n\r\nvoid bubbleSort(int[] arr, int i,int j,int n,boolean swapped) {\r\n        if(i == n-1) return;                       // i reaches end(n-1th elem) we return to the main\r\n        if(j == n-i){                                  // j reaches end of unsorted part of arr (n-i to n will be sorted) so we increment i and make j point to the start of arr\r\n            if(!swapped) return;                // if first n comparsions results in no swapping => the array is sorted so we return from here\r\n            i++;\r\n            j=1;\r\n        }\r\n        if(arr[j] < arr[j-1]){\r\n            int temp = arr[j];\r\n            arr[j] = arr[j-1];\r\n            arr[j-1] = temp;\r\n            swapped = true;                     // => swaping took place\r\n        }\r\n        j++;                                            // increment j\r\n        bubbleSort(arr, i, j, n,swapped); // recursive call\r\n    }\r\n\r\n//another implementation\r\nvoid bubbleSort(int[] arr, int n, boolean swapped) {\r\n        if(n==1) return;\r\n        for(int j = 1; j<n; j++){\r\n          if(arr[j] < arr[j-1]){\r\n            int temp = arr[j];\r\n            arr[j] = arr[j-1];\r\n            arr[j-1] = temp;\r\n            swapped = true;\r\n         }\r\n        }\r\n        if(!swapped) return;\r\n        bubbleSort(arr , n-1);\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699819",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c948",
		"title": "Cyclic sort",
		"postLinkTitle": "cyclic-sort",
		"desc": "//We use cyclic sort if we are given array to sort which contains values from range 1 to N\r\n// Here we compare each element with its index i.e index = value -1\r\n\r\n// index               0 1 2 3 4 5 6 7\r\n// arr values        1 2 3 4 5 6 7 8\r\n\r\nvoid cyclicSort(int[] arr){\r\n       int i = 0;\r\n       while(i < arr.length){\r\n             if(arr[i] == i + 1)  // if we have the correct value at the given index, so we move to next index\r\n                    i++;\r\n             else            //else we swap the current value with its correct position\r\n                    swap(arr, i, arr[i]-1);\r\n        }\r\n}\r\nvoid swap(int[] arr, int first, int second){\r\n        int temp = arr[first];\r\n        arr[first] = arr[second];\r\n        arr[second] = temp;\r\n}\r\n\r\n// if the range is from [0,N], then\r\n// index               0 1 2 3 4 5 6 7\r\n// arr values        0 1 2 3 4 5 6 7\r\n//here we compare arr[i] with i i.e arr[i] = i\r\n\r\n// if we have duplicates in the arr, we use arr[i] !=arr[correct] correct =arr[i] -1;\r\n\r\nproblems: \r\nhttps://leetcode.com/problems/missing-number/\r\n https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699821",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c94a",
		"title": "Search in a Rotated Sorted Array",
		"postLinkTitle": "search-in-a-rotated-sorted-array",
		"desc": "public int search(int[] arr, int target) {\r\n        int low = 0,high = arr.length - 1;\r\n        while(low <= high){\r\n            int mid = low + (high-low)/2;\r\n            if(arr[mid] == target){\r\n                return mid;\r\n            }\r\n            if(arr[low] <= arr[mid]){\r\n            //=> left of mid is sorted\r\n                if(target >= arr[low] && target < arr[mid]){\r\n//here, we check if the target is present in the left part of mid i.e arr[low]<=target<arr[mid]\r\n                    high = mid -1;\r\n                }else{\r\n                    low = mid + 1;\r\n                }\r\n            }else{\r\n            //=> right of mid is sorted\r\n                if(target > arr[mid] && target <= arr[high]){\r\n//here, we check if the target is present in the right part of mid i.e arr[mid]<target<arr[mid]\r\n                    low = mid + 1;\r\n                }else{\r\n                    high = mid - 1;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n\r\n    // 3 4 5 6 7 0 1 2\r\n    // s           p      e\r\n    //pivot is the element which is greater than the next element.\r\n    //pivot divides the array into 2 sorted arrays\r\n    //first we find pivot using findPivot\r\n    //if(pivot == -1) => the array is not rotated, so perform bs on the whole array\r\n    // if target(eg: 1) < start(eg:3) then we have to search in (pivot+1,end)\r\n    // else i.e. target(eg: 5) > start(eg:3) then we have to serach in (start, pivot-1)\r\n    \r\n    //*the array will be rotated pivot + 1 times\r\n    \r\n    public int search(int[] nums, int target) {\r\n        int start = 0, end = nums.length - 1;\r\n        int pivot = findPivot(nums,start,end);\r\n        if(pivot == -1)\r\n            return bS(nums,start,end,target);\r\n        if(nums[pivot] == target) return pivot;\r\n        if(nums[start] <= target) \r\n            return bS(nums,start,pivot-1,target);\r\n        return bS(nums,pivot+1,end,target);\r\n    }\r\n    \r\n    int findPivot(int[] arr, int start, int end){\r\n        while(start <= end){\r\n            int mid = start + (end - start)/2;\r\n            if(mid < end && arr[mid] > arr[mid + 1])\r\n                return mid;\r\n            if(mid > start && arr[mid] < arr[mid - 1])\r\n                return mid - 1;\r\n            if(arr[start] >= arr[mid]) end = mid -1;\r\n            else start = mid + 1;\r\n        }\r\n        return -1;\r\n    }\r\n    \r\n    int bS(int[] arr, int start, int end, int target){\r\n        while(start <= end){\r\n                int mid = start + (end - start) /2;\r\n                if(arr[mid] == target) return mid;\r\n                if(arr[mid] > target) end = mid -1;\r\n                else start = mid + 1;\r\n          }\r\n        return -1;\r\n    }\r\n\r\n// search in rotated sorted array if there exist duplicate elements in the array\r\n//  OC hai bhai\r\npublic boolean search(int[] nums, int target) {\r\n        int n = nums.length;\r\n        int pivot = findPivot(nums,0,n-1);\r\n        if(pivot == -1){ //the array is already sorted\r\n            return Bs(nums,0,n-1,target);\r\n        }\r\n        return Bs(nums,0,pivot,target) || Bs(nums,pivot+1,n-1,target); \r\n    }\r\n    public int findPivot(int[] arr,int lo,int hi){\r\n        while(lo <= hi){\r\n            int mid = (lo+hi)/2;\r\n            if(mid<arr.length-1 && arr[mid] > arr[mid+1]){\r\n                return mid;\r\n            }\r\n            if(arr[lo] == arr[mid]){ //if mid and starting elms are equal we check for pivot in the right and left side of mid\r\n                return Math.max(findPivot(arr,lo,mid-1),findPivot(arr,mid+1,hi));\r\n            }else if(arr[lo] < arr[mid]){\r\n                lo = mid+1;\r\n            }else{\r\n                hi = mid-1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    public boolean Bs(int[] arr,int lo,int hi,int key){\r\n        while(lo<=hi){\r\n            int mid = (lo+hi)/2;\r\n            if(arr[mid] == key){\r\n                return true;\r\n            }\r\n            if(arr[mid] <= key){\r\n                lo = mid+1;\r\n            }else{\r\n                hi=mid-1;\r\n            }\r\n        }\r\n        return false;\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699823",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c94c",
		"title": "First and Last Occurrence in a sorted array",
		"postLinkTitle": "first-and-last-occurrence-in-a-sorted-array",
		"desc": "public static Pair findFirstLastPosition(int[] arr, int n, int key) {\r\n        int start = 0,end = n-1;\r\n        int[] ans = new int[2];\r\n        ans[0] = -1;\r\n        ans[1] = -1;\r\n       //finding first index\r\n        while(start<=end){\r\n            int mid = start + (end-start)/2;\r\n            if(key>arr[mid]) start = mid + 1;\r\n            else if(key<arr[mid]) end = mid-1;\r\n            else{\r\n                arr[0] = mid;\r\n                end = mid - 1;\r\n            }\r\n        }\r\n        start = 0;\r\n        end = n-1;\r\n        //finding last index\r\n        while(start<=end){\r\n            int mid = start + (end-start)/2;\r\n            if(key>arr[mid]) start = mid + 1;\r\n            else if(key<arr[mid]) end = mid-1;\r\n            else{\r\n                arr[1] = mid;\r\n                end = mid - 1;\r\n            }\r\n        }\r\n        return ans;\r\n\t}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699824",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c94e",
		"title": "Rotate a Matrix in place(Clockwise and anti-clockwise)",
		"postLinkTitle": "rotate-a-matrix-in-place-clockwise-and-anti-clockwise",
		"desc": "//Anti-clockwise: https://www.geeksforgeeks.org/inplace-rotate-square-matrix-by-90-degrees/    \r\n//Clockwise: https://www.geeksforgeeks.org/rotate-a-matrix-by-90-degree-in-clockwise-direction-without-using-any-extra-space/\r\nint[][] antiClock(int[][] mat){\r\n        int n = mat.length, m = mat[0].length;\r\n        for(int i=0;i<n/2;i++){\r\n            for(int j=i;j<m-i-1;j++){\r\n                int temp = mat[i][j];\r\n                mat[i][j] = mat[j][n-i-1];\r\n                mat[j][n-i-1] = mat[n-i-1][m-j-1];\r\n                mat[n-i-1][m-j-1] = mat[m-j-1][i];\r\n                mat[m-j-1][i] = temp;\r\n            }\r\n        }\r\n        return mat;\r\n    }\r\n    int[][] clock(int[][] mat){\r\n        int n = mat.length;\r\n        for(int i=0;i<n/2;i++){\r\n            for(int j=i;j<n-i-1;j++){\r\n                int temp = mat[i][j];\r\n                mat[i][j] = mat[n-j-1][i];\r\n                mat[n-j-1][i] = mat[n-i-1][n-j-1];\r\n                mat[n-i-1][n-j-1] = mat[j][n-i-1];\r\n                mat[j][n-i-1] = temp;\r\n            }\r\n        }\r\n        return mat;\r\n    }\r\n// clockwise\r\npublic void rotate(ArrayList<ArrayList<Integer>> a) {\r\n        int n = a.size(), m = a.get(0).size();\r\n        for(int i=0;i<n/2;i++){\r\n            for(int j=i;j<m-i-1;j++){\r\n                int temp = a.get(i).get(j);\r\n                a.get(i).set(j, a.get(m-j-1).get(i));\r\n                a.get(m-j-1).set(i, a.get(n-i-1).get(m-j-1));\r\n                a.get(n-i-1).set(m-j-1, a.get(j).get(n-i-1));\r\n                a.get(j).set(n-i-1, temp);\r\n            }\r\n        }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699825",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c950",
		"title": "Merge Sort (in place using recursion)",
		"postLinkTitle": "merge-sort-in-place-using-recursion",
		"desc": "    int[] arr = new int[]{3,4,2,1,5,7,6};\r\n    mergeSort(arr,0,arr.length-1);\r\n    System.out.println(Arrays.toString(arr)); // [1,2,3,4,5,6,7]\r\nvoid mergeSort(int arr[], int l, int r)\r\n    {\r\n        if(l==r) return;\r\n        int mid = (l+r)/2;\r\n        mergeSort(arr,l,mid);\r\n        mergeSort(arr,mid+1,r);\r\n        merge(arr,l,mid,r);\r\n    }\r\n void merge(int arr[], int l, int m, int r)\r\n    {\r\n         int[] mergedArr = new int[r-l+1];\r\n         int i = l,j = m+1,k = 0;\r\n         while(i<=m && j<=r){\r\n            if(arr[i] < arr[j])\r\n                mergedArr[k] = arr[i++];\r\n            else\r\n                mergedArr[k] = arr[j++];\r\n            k++;\r\n         }\r\n         while(i<=m)\r\n            mergedArr[k++] = arr[i++];\r\n        while(j<=r)\r\n            mergedArr[k++] = arr[j++];\r\n        for(int f=0;f<mergedArr.length;f++)  // System.arraycopy(mergedArr,0,arr,l,r-l+1);\r\n            arr[l+f] = mergedArr[f];\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699827",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c952",
		"title": "Quick sort",
		"postLinkTitle": "quick-sort",
		"desc": "quickSort(arr,0,arr.length()-1);\r\n\r\n// rule: elements on the left side of pivot should less than pivot and elements on the right side of pivot should be more than pivot.\r\nstatic void quickSort(int arr[], int low, int high)\r\n    {\r\n        if(low>=high){\r\n            return;\r\n        }\r\n        int s = low, e = high,pivot = arr[s + (e-s)/2]; // this implementation works only when we choose mid element as pivot\r\n        while(s<=e){\r\n            while(arr[s] < pivot)   s++; // gives index of element which is greater than pivot and which is on the left side of pivot\r\n            while(arr[e] > pivot)   e--;  // gives index of element which is less than pivot and which is on the right side of pivot\r\n            if(s <= e){          // here we swap those two elements which violate our rule\r\n                int temp = arr[s];\r\n                arr[s] = arr[e];\r\n                arr[e] = temp;\r\n                s++;\r\n                e--;\r\n            }\r\n        }\r\n        quickSort(arr,low,e);  // recursive call on the left side of pivot i.e. (arr, low, e = pivot -1); \r\n        quickSort(arr,s,high);  // recursive call on the right side of pivot i.e. (arr , s = pivot +1,high);\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699828",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c954",
		"title": "Subsets of arrays and substrings of a String",
		"postLinkTitle": "subsets-of-arrays-and-substrings-of-a-string",
		"desc": "//https://www.youtube.com/watch?v=gdifkIwCJyg&list=PL9gnSGHSqcnr_DxHsP7AW9ftq0AtAyYqJ&index=28\r\n\r\n//subsets of an integer array\r\n\r\n//recursive\r\npublic List<List<Integer>> subsets(int[] nums) {\r\n        List<List<Integer>> ans = new ArrayList<>();\r\n        helper(nums,0,new ArrayList<Integer>(),ans);\r\n        return ans;\r\n    }\r\n    public void helper(int[] arr, int i, ArrayList<Integer> list, List<List<Integer>> ans) {\r\n        if(i==arr.length){\r\n            ans.add(new ArrayList<Integer>(list));\r\n            return;\r\n        }\r\n        list.add(arr[i]);\r\n        helper(arr,i+1,list,ans); //we include arr[i] here\r\n        list.remove(list.size()-1);\r\n        helper(arr, i+1, list, ans); //we leave arr[i]\r\n    }\r\n\r\n\r\n//iterative\r\npublic List<List<Integer>> subsets(int[] nums) {\r\n        List<List<Integer>> ans = new ArrayList<>();\r\n        ans.add(new ArrayList<>());\r\n        for(int i : nums){\r\n            int n = ans.size();\r\n            for(int j=0;j<n;j++){\r\n                List<Integer> temp = new ArrayList<>(ans.get(j));\r\n                temp.add(i);\r\n                ans.add(temp);\r\n            }\r\n        }\r\n//arr[1,2,3];\r\n// ans = [ [] ];\r\n//ans : [] -> [],[1] -> [],[1],[2],[1,2] -> [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]\r\n        return ans;\r\n    }\r\n\r\n\r\n//returning all the subsets of an array or list in non-decreasing and lexographical order\r\npublic class Solution {\r\n    public ArrayList<ArrayList<Integer>> subsets(ArrayList<Integer> A) {\r\n        Collections.sort(A);\r\n        ArrayList<ArrayList<Integer>> ans = new ArrayList<>();\r\n        ans.add(new ArrayList<Integer>());\r\n        for(int ele : A){\r\n            int n = ans.size();\r\n            for(int i=0;i<n;i++){\r\n                ArrayList<Integer> list = new ArrayList<>(ans.get(i));\r\n                list.add(ele);\r\n                ans.add(list);\r\n            }\r\n        }\r\n        Collections.sort(ans, new ListComparator<>());\r\n        return ans;\r\n    }\r\n    class ListComparator<T extends Comparable<T>> implements Comparator<List<T>> {\r\n        @Override\r\n        public int compare(List<T> o1, List<T> o2) {\r\n            for (int i = 0; i < Math.min(o1.size(), o2.size()); i++) {\r\n                int c = o1.get(i).compareTo(o2.get(i));\r\n                if (c != 0) {\r\n                    return c;\r\n                }\r\n            }\r\n            return Integer.compare(o1.size(), o2.size());\r\n        }\r\n    }\r\n}\r\n\r\n//finding unique subsets if the array contains duplicate elements\r\n//Don't know how but works OC\r\nclass Solution {\r\n    static List<List<Integer>> ans;\r\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\r\n        Arrays.sort(nums);\r\n        ans = new ArrayList<>();\r\n        ans.add(new ArrayList<Integer>());\r\n        helper(nums,0,new ArrayList<Integer>());\r\n        return ans;\r\n    }\r\n    public void helper(int[] nums,int i,List<Integer> list){\r\n        if(i == nums.length){\r\n            return;\r\n        }\r\n        Set<Integer> set = new HashSet<>();\r\n        for(int j=i;j<nums.length;j++){\r\n            if(set.add(nums[j])){\r\n                list.add(nums[j]);\r\n                helper(nums,j+1,list);\r\n                ans.add(new ArrayList<Integer>(list));\r\n                list.remove(list.size()-1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n//substrings of a String\r\npvsm{\r\n         String s = \"abc\";\r\n         List<Integer> ans = new ArrayList<>();\r\n         subStrings(s,\"\",ans);\r\n         System.out.println(ans);\r\n}\r\nvoid subStrings(String org, String mod, List<String> ans){\r\n        if(org.isEmpty()){\r\n             ans.add(mod);\r\n             return;\r\n        }\r\n        char c = org.charAt(0);\r\n        subStrings(org.subString(1),p+c,ans);\r\n        subStrings(org.subString(1),p,ans);\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699829",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c956",
		"title": "01 Knapsack (recursive and iterative)",
		"postLinkTitle": "01-knapsack-recursive-and-iterative",
		"desc": "static int[][] dp;\r\n    static int knapSack(int W, int wt[], int val[], int n) \r\n    { \r\n         dp = new int[n+1][W+1];\r\n         for(int[] i : dp){\r\n             Arrays.fill(i,-1);\r\n         }\r\n         return helper(W,wt,val,n);\r\n    }\r\n    static int helper(int W,int[] wt,int[] val,int n){\r\n        if(n==0 || W==0){\r\n             return dp[n][W] = 0;\r\n         }\r\n         if(dp[n][W] != -1){\r\n             return dp[n][W];\r\n         }\r\n         if(wt[n-1] > W){\r\n             return dp[n][W] = helper(W,wt,val,n-1);\r\n         }\r\n         return dp[n][W] =Math.max(val[n-1]+helper(W-wt[n-1],wt,val,n-1),helper(W,wt,val,n-1));\r\n    }\r\n\r\n//Iterative(Top-down)\r\n\r\nstatic int knapSack(int W, int wt[], int val[], int n) \r\n    { \r\n         // your code here \r\n         int[][] dp = new int[n+1][W+1];\r\n         for(int i=1;i<n+1;i++){\r\n             for(int j=1;j<W+1;j++){\r\n                if(wt[i-1]>j){\r\n                     dp[i][j] = dp[i-1][j];\r\n                 }else{\r\n                     dp[i][j] = Math.max(val[i-1] + dp[i-1][j-wt[i-1]] , dp[i-1][j]);\r\n                 }\r\n             }\r\n         }\r\n         return dp[n][W];\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699830",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c958",
		"title": "Subset Sum and Equals Sum partition problems.",
		"postLinkTitle": "subset-sum-and-equals-sum-partition-problems",
		"desc": "public class Main {\r\n    static int[][] dp;\r\n    public static void main(String[] args) {\r\n        int[] arr = {2,4,6,8};\r\n        int sum = 10,n=arr.length;\r\n        dp = new int[n+1][sum+1];\r\n        for(int[] i : dp)\r\n            Arrays.fill(i, -1);\r\n        System.out.println(helper(arr,sum,n)==1); //true\r\n        System.out.println(helper2(arr,sum,n)); //true\r\n        //equal sum partition\r\n        sum = 0;\r\n        for(int i : arr)\r\n            sum += i;\r\n        System.out.println( sum%2==0 && helper2(arr, sum/2, n) ); //true \r\n    }\r\n    //recursive\r\n    private static int helper(int[] arr, int sum, int n) {\r\n        if(sum==0){\r\n            return 1;\r\n        }\r\n        if(n==0){\r\n            return 0;\r\n        }\r\n        if(dp[n][sum] != -1) return dp[n][sum];\r\n\r\n        if(arr[n-1] > sum){\r\n            return dp[n][sum] = helper(arr, sum, n-1);\r\n        }\r\n        return dp[n][sum] = Math.max(helper(arr, sum - arr[n-1], n-1), helper(arr, sum, n-1));\r\n\r\n    }\r\n    //iterative or Top-down\r\n    public static boolean helper2(int[] arr, int sum, int n) {\r\n        boolean[][] t = new boolean[n+1][sum+1];\r\n        for (int i = 0; i <= sum; i++) {\r\n            t[0][i] = false;\r\n        }\r\n        for (int i = 0; i <= n; i++) {\r\n            t[i][0] = true;\r\n        }\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= sum; j++) {\r\n                if(arr[i-1]>j){\r\n                    t[i][j] = t[i-1][j];\r\n                }else{\r\n                    t[i][j] = t[i-1][j-arr[i-1]] || t[i-1][j];\r\n                }\r\n            }\r\n        }\r\n        return t[n][sum];\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699831",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c95a",
		"title": "Count of Subset sum of a given sum",
		"postLinkTitle": "count-of-subset-sum-of-a-given-sum",
		"desc": "arr = [2,4,6,8,10], n = 5\r\nsum = 10\r\nhelper(arr,n,sum) //(2,8),(4,6),(10) -> 3\r\n//recursive\r\nint helper(int[] arr,int n,int sum){\r\n       if(sum == 0) return 1;\r\n       if(n==0) return 0;\r\n       if(dp[n][sum] != -1) return d[n][sum];\r\n       if(arr[n-1] > sum) return dp[n][sum] = helper(arr,n-1,sum);\r\n       return dp[n][sum] = helper(arr,n-1,sum) + helper(arr,n-1,sum - arr[n-1]);\r\n}\r\n//iterative\r\nint helper2(int[] arr, int n,int sum){\r\n       for(int i=0;i<=sum;i++)  dp[0][i] = 0;\r\n       for(int i=0;i<=n;i++)  dp[i][0] = 1;\r\n       for(int i=1;i<=n;i++){\r\n          for(int j=1;j<=sum;j++){\r\n              if(arr[i-1] > j) dp[i][j] = dp[i-1][j];\r\n              else dp[i][j] = dp[i-1][j] + dp[i-1][j-arr[i-1]];\r\n          }\r\n       }\r\n       return dp[n][sum];\r\n} ",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699832",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c95c",
		"title": "Minimum subset difference",
		"postLinkTitle": "minimum-subset-difference",
		"desc": "public class Main {\r\n    static boolean[][] dp;\r\n    public static void main(String[] args) {\r\n        int[] arr = {1,2,4,7};\r\n        int sum = 0,n=arr.length;\r\n        for(int i : arr)\r\n            sum += i;\r\n        dp = new boolean[n+1][sum+1];\r\n        subsetSum(arr, sum, n);\r\n        int ans = Integer.MAX_VALUE;\r\n        for(int i=1;i<=sum/2;i++){\r\n            if(dp[n][i]) \r\n                ans = Math.min(ans,sum - 2*i);\r\n        }\r\n        System.out.println(ans);\r\n    }\r\n    public static void subsetSum(int[] arr, int sum, int n) {\r\n        for (int i = 0; i <= sum; i++) {\r\n            dp[0][i] = false;\r\n        }\r\n        for (int i = 0; i <= n; i++) {\r\n            dp[i][0] = true;\r\n        }\r\n        for (int i = 1; i <= n; i++) {\r\n            for (int j = 1; j <= sum; j++) {\r\n                if(arr[i-1]>j){\r\n                    dp[i][j] = dp[i-1][j];\r\n                }else{\r\n                    dp[i][j] = dp[i-1][j-arr[i-1]] || dp[i-1][j];\r\n                }\r\n            }\r\n        }\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699833",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c95e",
		"title": "Multiplying Strings",
		"postLinkTitle": "multiplying-strings",
		"desc": "public String multiply(String num1, String num2) {\r\n        if(num1.equals(\"0\") || num2.equals(\"0\")) \r\n               return \"0\";\r\n        int a=num1.length(),b=num2.length();\r\n        int[] n1 = new int[a];\r\n        int[] n2 = new int[b];\r\n        int[] res = new int[a+b]; //result can't exceed a+b\r\n        int k = 0;\r\n        for(char c : num1.toCharArray()){\r\n            n1[k++] = c - '0';\r\n        }\r\n        k = 0;\r\n        for(char c : num2.toCharArray()){\r\n            n2[k++] = c - '0';\r\n        }\r\n        k = a+b-1;\r\n        int carry = 0;\r\n        for(int i=a-1;i>=0;i--){\r\n            for(int j=0;j<b;j++){\r\n                int temp = res[k-j] + n1[i]*n2[b-1-j] + carry;\r\n                res[k-j] = temp % 10;\r\n                carry = temp/10;\r\n            }\r\n            if(carry != 0){\r\n                res[k-b] = carry;\r\n                carry = 0;\r\n            }\r\n            k--;\r\n        }\r\n        String ans = \"\";\r\n        int i = (res[0] == 0)?1:0; //we get extra 0 at the beginning of array for some numbers so we start from next pos\r\n        while(i<a+b)\r\n            ans += res[i];\r\n        return ans;\r\n    }\r\n\r\n//gfg: https://practice.geeksforgeeks.org/problems/multiply-two-strings/1/\r\nclass Solution\r\n{\r\n    public String multiplyStrings(String s1,String s2)\r\n    {\r\n        //code here.\r\n        boolean isNeg = false;\r\n        if(s1.charAt(0) == '-'){\r\n            s1 = s1.substring(1);\r\n            isNeg = !isNeg;\r\n        }\r\n        if(s2.charAt(0) == '-'){\r\n            s2 = s2.substring(1);\r\n            isNeg = !isNeg;\r\n        }\r\n        s1 = removeLeadingZeros(s1);\r\n        s2 = removeLeadingZeros(s2);\r\n        if(s1.equals(\"0\") || s2.equals(\"0\")){\r\n            return \"0\";\r\n        }\r\n        int n = s1.length(),m = s2.length();\r\n        int[] a = convert(s1,n);\r\n        int[] b = convert(s2,m);\r\n        int[] c = new int[n+m];\r\n        String ans = multiply(a,b,c,n,m);\r\n        if(isNeg) ans = \"-\"+ans;\r\n        return ans;\r\n    }\r\n    public int[] convert(String s,int n){\r\n        int[] arr = new int[n];\r\n        char[] ch = s.toCharArray();\r\n        for(int i=0;i<n;i++){\r\n            arr[i] = ch[i]-'0';\r\n        }\r\n        return arr;\r\n    }\r\n    public String removeLeadingZeros(String s){\r\n        int k = 0;\r\n        while(k<s.length() && s.charAt(k) == '0'){\r\n            k++;\r\n        }\r\n        if(k == s.length()){\r\n            return \"0\";\r\n        }\r\n        return s.substring(k);\r\n    }\r\n    public String multiply(int[] a,int[] b,int[] c,int n,int m){\r\n        int carry = 0,k=n;\r\n        for(int i=n-1;i>=0;i--){\r\n            for(int j=m-1;j>=0;j--){\r\n                int temp = b[j]*a[i] + c[k+j] + carry;\r\n                c[k+j] = temp%10;\r\n                carry = temp/10;\r\n            }\r\n            if(carry != 0){\r\n                c[k-1] += carry;\r\n                carry = 0;\r\n            }\r\n            k--;\r\n        }\r\n        // System.out.println(Arrays.toString(c)+\"\\n\"+Arrays.toString(a)+\"\\n\"+Arrays.toString(b));\r\n        StringBuilder s = new StringBuilder(\"\");\r\n        k = (c[0] == 0)?1:0;\r\n        while(k<c.length){\r\n            s.append(c[k]);\r\n            k++;\r\n        }\r\n        return s.toString();\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699834",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c960",
		"title": "Longest Common Subsequence of 2 Strings",
		"postLinkTitle": "longest-common-subsequence-of-2-strings",
		"desc": "public class Main {\r\n\tstatic int[][] dp;\r\n    public static void main (String[] args) throws java.lang.Exception\r\n\t{\r\n\t\tString A = \"abcd\";\r\n\t\tString B = \"bieurcoid\";\r\n\t\tdp = new int[A.length()+1][B.length()+1];\r\n\t\tfor(int[] i : dp)\r\n\t\t\tArrays.fill(i, -1);\r\n\t\tint ansRec = helperRec(A,B,A.length(),B.length());\r\n\t\tint ans = helper(A,B);\r\n\t\tSystem.out.println(ansRec + \" \" + ans);\r\n\t}\r\n\tprivate static int helper(String a, String b) {\r\n\t\tfor(int[] i : dp)\r\n\t\t\tArrays.fill(i, -1);\r\n\t\tfor (int i = 0; i <= a.length(); i++) {\r\n\t\t\tfor (int j = 0; j <= b.length(); j++) {\r\n\t\t\t\tif(i==0 || j==0){\r\n\t\t\t\t\tdp[i][j] = 0;\r\n\t\t\t\t}else if(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1];\r\n\t\t\t\t}else{\r\n\t\t\t\t\tdp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn dp[a.length()][b.length()];\r\n\t}\r\n\tprivate static int helperRec(String a, String b, int i, int j) {\r\n\t\tif(i==0 || j==0){\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif(dp[i][j] != -1){\r\n\t\t\treturn dp[i][j];\r\n\t\t}\r\n\t\tif(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\treturn dp[i][j] = 1 + helperRec(a, b, i-1, j-1);\r\n\t\t}\r\n\t\treturn dp[i][j] = Math.max(helperRec(a, b, i-1, j), helperRec(a, b, i, j-1));\r\n\t}\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699835",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c962",
		"title": "No. of paths to reach to the end of matrix",
		"postLinkTitle": "no-of-paths-to-reach-to-the-end-of-matrix",
		"desc": "//No. of paths to reach to the end of matrix if we can move only in right and down direction\r\nclass Solution\r\n{\r\n    static int[][] dp;\r\n    //Function to find total number of unique paths.\r\n    public static int NumberOfPath(int a, int b) \r\n    {\r\n        //Your code here\r\n        dp = new int[a+1][b+1];\r\n        for(int[] i : dp)\r\n            Arrays.fill(i,-1);\r\n        // for(int i=1;i<=a;i++){\r\n        //     for(int j=1;j<=b;j++){\r\n        //         if(i==1 || b==1){\r\n        //             dp[i][j] = 1;\r\n        //         }else{\r\n        //             dp[i][j] = dp[i-1][j] + dp[i][j-1];\r\n        //         }\r\n        //     }\r\n        // }\r\n        return helper(a,b);\r\n    }\r\n    public static int helper(int a,int b){\r\n        if(a==1 || b==1){  //=>we are on the boundary of matrix i.e. right most col and bottom most col, here we have only one choice to go either only down or only right resp\r\n            return 1;\r\n        }\r\n        if(dp[a][b] != -1) \r\n            return dp[a][b];\r\n        return dp[a][b] = helper(a-1,b) + helper(a,b-1); //=> we calc no. of ways if we go down + no. of ways if we go right\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699836",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c964",
		"title": "Longest Common Substring",
		"postLinkTitle": "longest-common-substring",
		"desc": "class Solution{\r\n    int longestCommonSubstr(String S1, String S2, int n, int m){\r\n       return helper(S1,S2,n,m);\r\n    }\r\n\tpublic int helper(String a, String b, int n, int m) {\r\n\t    int[][] dp = new int[n+1][m+1];\r\n\t\tint ans = 0;\r\n\t\tfor(int i=1;i<=n;i++){\r\n\t\t\tfor (int j = 1; j <= m; j++) {\r\n\t\t\t\tif(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1];\r\n\t\t\t\t\tans = Math.max(ans, dp[i][j]);\r\n\t\t\t\t}else{\r\n\t\t\t\t\tdp[i][j] = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ans;\r\n\t}\r\n\r\n\r\n//recursive\r\n/// couldn't find memoized version\r\n      public int helper(String a, String b, int i, int j, int count) {\r\n\t\tif(i==0 || j==0){\r\n\t\t\treturn count;\r\n\t\t}\r\n\t\tif(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\tcount = helper(a, b, i-1, j-1, count+1);\r\n\t\t}\r\n\t\tcount = Math.max(count,Math.max(helper(a, b, i-1, j, 0), helper(a, b, i, j-1, 0)));\r\n\t\treturn count;\r\n\t}\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699837",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c966",
		"title": "Rain Water Trapping Problem",
		"postLinkTitle": "rain-water-trapping-problem",
		"desc": "static long trappingWater(int arr[], int n) { \r\n        //we maintain left array to store max height of block on the left side of each index\r\n        int[] left = new int[n];\r\n        //we maintain right array to store max height of block on the right side of each index\r\n        int[] right = new int[n];\r\n        left[0] = arr[0];\r\n        for(int i=1;i<n;i++){\r\n            left[i] = Math.max(left[i-1],arr[i]);\r\n        }\r\n        right[n-1] = arr[n-1];\r\n        for(int i=n-2;i>=0;i--){\r\n            right[i] = Math.max(right[i+1],arr[i]);\r\n        }\r\n        long ans = 0;\r\n        for(int i=1;i<n-1;i++){\r\n           //here we are doing ( min(left,right) height - current height ) to get max amount of water that can be stored at that index\r\n            ans += Math.min(left[i],right[i]) - arr[i];\r\n        }\r\n        return ans;\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699838",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c96a",
		"title": "Printing Shortest Common Super Sequence",
		"postLinkTitle": "printing-shortest-common-super-sequence",
		"desc": "import java.util.Arrays;\r\n\r\npublic class Main {\r\n\tstatic int[][] dp;\r\n    public static void main (String[] args) throws java.lang.Exception\r\n\t{\r\n\t\t// Scanner in = new Scanner(new FileInputStream(\"input.txt\"));\r\n\t\tString a = \"geek\";\r\n\t\tString b = \"eke\";\r\n\t\tint i=a.length(),j=b.length();\r\n\t\tdp = new int[i+1][j+1];\r\n\t\tfor(int[] arr : dp)\r\n\t\t\tArrays.fill(arr, -1);\r\n\t\thelper(a,b,i,j);\r\n\t\tSystem.out.println(generateLCS(a, b, i, j));\r\n\t}\r\n\tpublic static String generateLCS(String a, String b, int i, int j) {\r\n\t\tStringBuilder s = new StringBuilder();\r\n\t\twhile(i>0 && j>0){\r\n\t\t\tif(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\t\ts.insert(0, a.charAt(i-1));\r\n\t\t\t\ti--; j--;\r\n\t\t\t}else if(dp[i-1][j] > dp[i][j-1]){\r\n\t\t\t\ts.insert(0,a.charAt(i-1));\r\n\t\t\t\ti--;\r\n\t\t\t}else{\r\n\t\t\t\ts.insert(0,b.charAt(j-1));\r\n\t\t\t\tj--;\r\n\t\t\t}\r\n\t\t}\r\n\t\twhile(i>0){\r\n\t\t\ts.insert(0, a.charAt(i-1));\r\n\t\t\ti--;\r\n\t\t}\r\n\t\twhile(j>0){\r\n\t\t\ts.insert(0, b.charAt(j-1));\r\n\t\t\tj--;\r\n\t\t}\r\n\t\treturn s.toString();\r\n\t}\r\n\tpublic static int helper(String a, String b, int i, int j) {\r\n\t\tif(i==0 || j==0){\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif(dp[i][j] != -1) \r\n\t\t\treturn dp[i][j];\r\n\t\tif(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\treturn dp[i][j] = 1 + helper(a, b, i-1, j-1);\r\n\t\t}\r\n\t\treturn dp[i][j] = Math.max(helper(a, b, i-1, j) , helper(a, b, i, j-1));\r\n\t}\r\n\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699839",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c968",
		"title": "Printing Longest Common Subsequence",
		"postLinkTitle": "printing-longest-common-subsequence",
		"desc": "public class Main {\r\n    static int[][] dp;\r\n    public static void main (String[] args) throws java.lang.Exception\r\n\t{\r\n\t\tString a = \"abcdrefs\";\r\n\t\tString b = \"acdbns\";\r\n\t\tint i=a.length(),j=b.length();\r\n\t\tdp = new int[i+1][j+1];\r\n\t\tfor(int[] arr : dp)\r\n\t\t\tArrays.fill(arr, -1);\r\n\t\thelper(a,b,i,j);\r\n\t\tSystem.out.println(generateLCS(a, b, i, j));\r\n\t}\r\n\tpublic static String generateLCS(String a, String b, int i, int j) {\r\n\t\tStringBuilder s = new StringBuilder();\r\n\t\twhile(i>0 && j>0){\r\n\t\t\tif(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\t\ts.insert(0, a.charAt(i-1));\r\n\t\t\t\ti--; j--;\r\n\t\t\t}else if(dp[i-1][j] > dp[i][j-1]){\r\n\t\t\t\ti--;\r\n\t\t\t}else{\r\n\t\t\t\tj--;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn s.toString();\r\n\t}\r\n\tpublic static int helper(String a, String b, int i, int j) {\r\n\t\tif(i==0 || j==0){\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif(dp[i][j] != -1) \r\n\t\t\treturn dp[i][j];\r\n\t\tif(a.charAt(i-1) == b.charAt(j-1)){\r\n\t\t\treturn dp[i][j] = 1 + helper(a, b, i-1, j-1);\r\n\t\t}\r\n\t\treturn dp[i][j] = Math.max(helper(a, b, i-1, j) , helper(a, b, i, j-1));\r\n\t}\r\n\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699839",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c96c",
		"title": "Generate Parenthesis",
		"postLinkTitle": "generate-parenthesis",
		"desc": "class Solution {\r\n    public List<String> generateParenthesis(int n) {\r\n        return helper(new StringBuilder(\"\"),0,0,n);\r\n    }\r\n    public List<String> helper(StringBuilder s,int open,int close,int max){\r\n        if(s.length() == 2*max){\r\n            List<String> list = new ArrayList<>();\r\n            list.add(s.toString());\r\n            return list;\r\n        }\r\n        List<String> list = new ArrayList<>();\r\n        if(open<max){\r\n            s.append(\"(\");\r\n            list.addAll(helper(s,open+1,close,max));\r\n            s.deleteCharAt(s.length() - 1);\r\n        }\r\n        if(close<open){\r\n            s.append(\")\");\r\n            list.addAll(helper(s,open,close+1,max));\r\n            s.deleteCharAt(s.length() - 1);\r\n        }\r\n        return list;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699840",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c96e",
		"title": "Maximal String using Recursion and Backtracking",
		"postLinkTitle": "maximal-string-using-recursion-and-backtracking",
		"desc": "//finding lexographically maximum string premution which is formed by making atmost k swaps\r\n\r\npublic class Solution {\r\n    public String solve(String A, int B) {\r\n        return helper(A.toCharArray(),B);\r\n    }\r\n    public String helper(char[] arr, int k){\r\n        if(k==0){\r\n            return new String(arr);\r\n        }\r\n        int n = arr.length;\r\n        String max = new String(arr);\r\n        for (int i = 0; i < n - 1; i++) {\r\n            for (int j = i + 1; j < n; j++) {\r\n                if (arr[j] > arr[i]) {\r\n                    swap(arr,j,i);\r\n                    String ans = helper(arr,k-1);\r\n                    if(max.compareTo(ans) <0){\r\n                        max = ans;\r\n                    }\r\n                    swap(arr,i,j);\r\n                }\r\n            }\r\n        }\r\n        return max;\r\n    }\r\n    public void swap(char[] arr,int i,int j){\r\n        char temp = arr[i];\r\n        arr[i] = arr[j];\r\n        arr[j] = temp;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699841",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c970",
		"title": "Word Break Problem",
		"postLinkTitle": "word-break-problem",
		"desc": "//gfg prctice - https://practice.geeksforgeeks.org/problems/word-break-part-23249/1#\r\nclass Solution{\r\n    static List<String> ans;\r\n    static List<String> wordBreak(int n, List<String> dict, String s)\r\n    {\r\n        // code here\r\n        ans = new ArrayList<>();\r\n        helper(s,dict,\"\");\r\n        return ans;\r\n    }\r\n    static void helper(String s,List<String> dict,String f){\r\n        if(s.length() == 0){\r\n            ans.add(f.substring(1));\r\n            return;\r\n        }\r\n        for(String word : dict){\r\n            if(s.startsWith(word)){\r\n                helper(s.substring(word.length()),dict,f+\" \"+word);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\nclass Solution{\r\n    static List<String> ans;\r\n    static List<String> wordBreak(int n, List<String> dict, String s)\r\n    {\r\n        ans = new ArrayList<>();\r\n        helper(s,0,1,dict,\"\");\r\n        return ans;\r\n    }\r\n    static void helper(String s,int i,int j,int n,List<String> dict,String f){\r\n          if(s.length()==0){\r\n                ans.add(f.substring(1));  //extra \" \" at the beginning of f. Eg: \" cats and dog\" , \" cat sand dog\".\r\n                return;\r\n        }\r\n        if(j == s.length()+1){\r\n               return;\r\n        }\r\n        //if i,j forms a valid word then we add it to the f with a space at the beginning and next func called upon the remaining string\r\n        if(dict.contains(s.substring(i,j))){  \r\n            helper(s.substring(j),0,1,dict,f +\" \"+s.substring(i,j));\r\n        }\r\n        // this calls func on the next value of j\r\n        helper(s,i,j+1,dict,f); \r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699842",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c972",
		"title": "Family Structure or Generation Problem",
		"postLinkTitle": "family-structure-or-generation-problem",
		"desc": "public static String kthChildNthGeneration(int level, long pos) {\r\n        //generations start with Male || the first child of each generation or level will be male\r\n        if(level == 1 || pos == 1){\r\n            return \"Male\";\r\n        }\r\n        //here we check the gender of parent to find the gender of child i.e the first child(odd pos) will have the same gender of parent and the 2nd will have diff gender.\r\n        if(kthChildNthGeneration(level-1,(pos+1)/2) == \"Male\"){\r\n            return (pos&1) == 1 ? \"Male\" : \"Female\";\r\n        }\r\n        return (k&1) == 1 ? \"Female\" : \"Male\";\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699843",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c974",
		"title": "Run Length encoding in O(N)",
		"postLinkTitle": "run-length-encoding-in-o-n",
		"desc": "// Run length encoding - converting aaaabbbccdaa -> a4b3c2d1a2\r\n\r\npublic static String encode(String message) {\r\n        StringBuilder ans = new StringBuilder(\"\");\r\n        int prev = 0,n=message.length();\r\n        for(int i=0;i<=n;i++){\r\n           // if prev != curr we add prev to ans with count as diff of indexes and update prev with curr\r\n          // i==n is for final char count\r\n            if(i==n || message.charAt(prev) != message.charAt(i)){\r\n                ans.append(message.charAt(prev));\r\n                ans.append(i-prev);\r\n                prev = i;\r\n            }\r\n        }\r\n        return ans.toString();\r\n\t}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699844",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c978",
		"title": "Inversion Count or Smaller elements problem",
		"postLinkTitle": "inversion-count-or-smaller-elements-problem",
		"desc": "/*\r\nInversion Count: For an array, inversion count indicates how far (or close) the array is from being sorted.\r\nIf array is already sorted then the inversion count is 0.\r\nIf an array is sorted in the reverse order then the inversion count is the maximum. \r\nFormally, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j.\r\nor\r\nFor a given index i, the inversion count is the no. elements which are less than arr[i] and on the right side of i. \r\n*/\r\n\r\n//problem links - https://www.hackerrank.com/contests/smart-interviews/challenges/si-smaller-elements/problem, \r\n//https://practice.geeksforgeeks.org/problems/inversion-of-array-1587115620/1\r\n\r\nimport java.io.*;\r\nimport java.util.*;\r\n\r\npublic class Solution {\r\n    static long cnt;\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        int t = in.nextInt();\r\n        StringBuilder ans = new StringBuilder(\"\");\r\n        while(t-- > 0){\r\n            int n = in.nextInt();\r\n            int[] arr = new int[n];\r\n            for(int i=0;i<n;i++){\r\n                arr[i] = in.nextInt();\r\n            }\r\n            cnt = 0;\r\n            mergeSort(arr,0,n-1);\r\n            ans.append(cnt+\"\\n\");\r\n        }\r\n        System.out.print(ans);\r\n    }\r\n    \r\n    public static void mergeSort(int[] arr,int lo,int hi){\r\n        if(lo==hi) return;\r\n        int mid = (lo+hi)/2;\r\n        mergeSort(arr,lo,mid);\r\n        mergeSort(arr,mid+1,hi);\r\n        merge(arr,lo,hi);\r\n    }\r\n    public static void merge(int[] arr,int lo,int hi){\r\n        int[] temp = new int[hi-lo+1];\r\n        int mid = (lo+hi)/2, p1 = lo, p2 = mid+1, k=0;\r\n        while(p1<=mid && p2<=hi){\r\n            if(arr[p1]<=arr[p2]) temp[k++] = arr[p1++];\r\n            else{ \r\n                //here if one of the elem of rightside half of arr < elem of left half then we increment the count by \r\n                //no. of elem on the rightside including that elem(since the both halves are sorted).\r\n                // [3 4 6 8] [ 1 2 7] => 3>2 so incr cnt by 1(3 itself) + no. of elem on the right side(4,6,8 which are also > 3) = 1 + 3 =4\r\n                cnt += mid-p1+1;\r\n                temp[k++] = arr[p2++];\r\n            }\r\n        }\r\n        while(p1<=mid) temp[k++] = arr[p1++];\r\n        while(p2<=hi) temp[k++] = arr[p2++];\r\n        k=lo;\r\n        for(int i : temp){\r\n            arr[k++] = i;\r\n        }\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699845",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c976",
		"title": "Finding Frequency of an element in an array using different ways",
		"postLinkTitle": "finding-frequency-of-an-element-in-an-array-using-different-ways",
		"desc": "public class Solution {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        int n = in.nextInt();\r\n        int[] arr = new int[n];\r\n        for(int i=0;i<n;i++){\r\n            arr[i] = in.nextInt();\r\n        }\r\n        Arrays.sort(arr);\r\n        int Q = in.nextInt();\r\n        StringBuilder ans = new StringBuilder(\"\");\r\n        while(Q-- > 0){\r\n            int q = in.nextInt();\r\n            int p1 = bsFloor(arr,0,n-1,q);//gives rightmost occurence of q i.e 0 1 2 2 2 2 5 bsFloor(arr,2)=>5(0-based index)\r\n            int p2 = bsCeil(arr,0,n-1,q);//gives leftmost occurence of q i.e 0 1 2 2 2 2 5 bsCeil(arr,2)=>2\r\n            if(p1 == -1){ //if elem is not found\r\n                ans.append(\"0\\n\");\r\n            }else ans.append(p1-p2+1+\"\\n\");\r\n        }\r\n        System.out.print(ans);\r\n    }\r\n\r\n    public static int bsFloor(int[] arr,int lo,int hi,int key){\r\n        int index = -1;\r\n        while(lo <= hi){\r\n            int mid = (lo+hi)/2;\r\n            if(arr[mid] <= key){\r\n                index = mid;\r\n                lo = mid+1;\r\n            }else{\r\n                hi = mid-1;\r\n            }\r\n        }\r\n        return index; //or 'hi' \r\n    }\r\n\r\n    public static int bsCeil(int[] arr,int lo,int hi,int key){\r\n       int index = -1;\r\n        while(lo <= hi){\r\n            int mid = (lo+hi)/2;\r\n            if(arr[mid] >= key){\r\n                index = mid;\r\n                hi = mid-1;\r\n            }else{\r\n                lo = mid+1;\r\n            }\r\n        }\r\n        return index; // or lo\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699845",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c97a",
		"title": "Print All the Permutations of an Array/List",
		"postLinkTitle": "print-all-the-permutations-of-an-array-list",
		"desc": "//using visited array\r\nclass Solution {\r\n    static List<List<Integer>> ans;\r\n    static boolean[] vis;\r\n    public List<List<Integer>> permute(int[] nums) {\r\n        ans  = new ArrayList<>();\r\n        vis = new boolean[nums.length];\r\n        helper(nums,nums.length,new ArrayList<Integer>());\r\n        return ans;\r\n    }\r\n    public void helper(int[] nums,int i,ArrayList<Integer> list){\r\n        if(i==0){\r\n            ans.add(new ArrayList<Integer>(list));\r\n            return;\r\n        }\r\n        for(int j=0;j<nums.length;j++){\r\n            if(!vis[j]){\r\n                vis[j] = true;\r\n                list.add(nums[j]);\r\n                helper(nums,i-1,list);\r\n                vis[j] = false;\r\n                list.remove(list.size()-1);\r\n            }\r\n        }\r\n    }\r\n}\r\n//By swapping elements\r\nclass Solution {\r\n    static List<List<Integer>> ans;\r\n    public List<List<Integer>> permute(int[] nums) {\r\n        ans  = new ArrayList<>();\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n        for(int i : nums){\r\n            arr.add(i);\r\n        }\r\n        helper(arr,0);\r\n        return ans;\r\n    }\r\n    public void helper(ArrayList<Integer> arr,int i){\r\n        if(i==arr.size()){\r\n            ans.add(new ArrayList<Integer>(arr));\r\n            return;\r\n        }\r\n        for(int j=i;j<arr.size();j++){\r\n            swap(arr,i,j);\r\n            helper(arr,i+1);\r\n            swap(arr,i,j);\r\n        }\r\n    }\r\n    public void swap(ArrayList<Integer> arr,int i,int j){\r\n        int temp = arr.get(i);\r\n        arr.set(i,arr.get(j));\r\n        arr.set(j,temp);\r\n    }\r\n}\r\n\r\n//printing unique permutations if array/list contains duplicate elements\r\n//using visited set\r\nclass Solution {\r\n    static List<List<Integer>> ans;\r\n    public List<List<Integer>> permuteUnique(int[] nums) {\r\n        ans = new ArrayList<>();\r\n        ArrayList<Integer> arr = new ArrayList<>();\r\n        for(int i : nums){\r\n            arr.add(i);\r\n        }\r\n        helper(arr,0);\r\n        return ans;\r\n    }\r\n    public void helper(ArrayList<Integer> arr,int i){\r\n        if(i==arr.size()){\r\n            ArrayList<Integer> list = new ArrayList<Integer>(arr);\r\n            ans.add(list);\r\n            return;\r\n        }\r\n        Set<Integer> vis = new HashSet<>();\r\n        for(int j=i;j<arr.size();j++){\r\n            if(vis.contains(arr.get(j))) //=> if elem is already swapped we don't swap it again\r\n                continue;\r\n            vis.add(arr.get(j));\r\n            swap(arr,i,j);\r\n            helper(arr,i+1);\r\n            swap(arr,i,j);\r\n        }\r\n    }\r\n    public void swap(ArrayList<Integer> arr,int i,int j){\r\n        int temp = arr.get(i);\r\n        arr.set(i,arr.get(j));\r\n        arr.set(j,temp);\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699846",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c97c",
		"title": "Word search in a matrix of characters",
		"postLinkTitle": "word-search-in-a-matrix-of-characters",
		"desc": "class Solution {\r\n    static int r,c;\r\n    public boolean exist(char[][] board, String word) {\r\n        r=board.length;\r\n        c=board[0].length;\r\n        for(int i=0;i<r;i++){\r\n            for(int j=0;j<c;j++){\r\n                if(word.charAt(0) == board[i][j]){  \r\n                    //if the first char is matching then we can continue with this i,j\r\n                    if(helper(board,word,i,j,0)){\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    public boolean helper(char[][] board, String word, int i, int j,int index){\r\n        if(index == word.length()){ //word is formed or found\r\n            return true;\r\n        }\r\n        if(i<0 || i==r || j<0 || j==c || board[i][j] == '-'){ \r\n            //checking if we went out of matrix or visiting the already visited box\r\n            return false;\r\n        }\r\n        if(board[i][j] != word.charAt(index)){ \r\n            //if the char is not matching with the word at pos index we need not check further\r\n            return false;\r\n        }\r\n        char ch = board[i][j];\r\n        board[i][j] = '-'; // marking the box as visited\r\n        boolean flag = helper(board,word,i,j+1,index+1) || helper(board,word,i,j-1,index+1) ||\r\n            helper(board,word,i+1,j,index+1) || helper(board,word,i-1,j,index+1);\r\n        board[i][j] = ch; // backtracking\r\n        return flag;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699847",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c97e",
		"title": "Anagrams of String",
		"postLinkTitle": "anagrams-of-string",
		"desc": "//printing all the possible anagrams of string\r\npublic void anagrams(String str, int start, int end) \r\n    { \r\n        if (start == end) \r\n            System.out.println(str); \r\n        else { \r\n            for (int i = start; i <= end; i++) { \r\n                str = swap(str, start, i); \r\n                anagm(str, start + 1, end); \r\n                str = swap(str, start, i); \r\n            } \r\n        } \r\n    } \r\n    public String swap(String a, int i, int j) \r\n    { \r\n        char temp; \r\n        char[] charArray = a.toCharArray(); \r\n        temp = charArray[i]; \r\n        charArray[i] = charArray[j]; \r\n        charArray[j] = temp; \r\n        return String.valueOf(charArray); \r\n    }\r\n\r\n// check if string b is an anagram of a or vice-versa\r\n public boolean check(String a,String b){\r\n          if(a.length() != b.length()) return false;\r\n          a = sort(a);\r\n          b = sort(b);\r\n          return a.equals(b);\r\n}\r\npublic String sort(String s){\r\n        char[] ch = s.toCharArray();\r\n        Arrays.sort(ch);\r\n        return String.valueOf(ch);\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699850",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c980",
		"title": "Creating a server using only Node.Js",
		"postLinkTitle": "creating-a-server-using-only-node-js",
		"desc": "//tutorial link : https://youtu.be/2LUdnb-mls0\r\nconst http = require('http');\r\nconst fs = require('fs');\r\nconst server = http.createServer((req,res)=>{\r\n    res.statusCode = 200;\r\n    res.setHeader('Content-Type','text/html');\r\n    res.end(fs.readFileSync(\"./index.html\"));\r\n})\r\nserver.listen(port, ()=>{\r\n    console.log(`Server is listening at http://192.168.31.5:${port}`);\r\n})",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699851",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c982",
		"title": "Insertion Sort",
		"postLinkTitle": "insertion-sort",
		"desc": "private static void sort(int[] arr) {\r\n        for(int i=0;i<arr.length-1;i++){\r\n            for(int j=i+1;j>0;j--){\r\n                if(arr[j] < arr[j-1]){\r\n                    swap(arr,j,j-1);\r\n                }else{\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    private static void swap(int[] arr, int a, int b) {\r\n        int temp = arr[a];\r\n        arr[a] = arr[b];\r\n        arr[b] = temp;\r\n    }\r\n\r\nParallel sort\r\npublic static void llelSort(int[] primary,int[] secondary, int l, int r){\r\n        if(l==r) return;\r\n        int mid = (l+r)/2;\r\n        llelSort(primary,secondary,l,mid);\r\n        llelSort(primary,secondary,mid+1,r);\r\n        merge(primary,secondary,l,mid,r);\r\n    }\r\n    public static void merge(int[] primary,int[] secondary, int l, int m, int r){\r\n         int[] mergedArr = new int[r-l+1];\r\n         int[] mergedArr2 = new int[r-l+1];\r\n         int i = l,j = m+1,k = 0;\r\n         while(i<=m && j<=r){\r\n            if(primary[i] < primary[j]){\r\n                mergedArr[k] = primary[i];\r\n                mergedArr2[k] = secondary[i++];\r\n            }\r\n            else{\r\n                mergedArr[k] = primary[j];\r\n                mergedArr2[k] = secondary[j++];\r\n            }\r\n            k++;\r\n         }\r\n         while(i<=m){\r\n            mergedArr[k] = primary[i];\r\n            mergedArr2[k++] = secondary[i++];\r\n        }\r\n        while(j<=r){\r\n            mergedArr[k] = primary[j];\r\n            mergedArr2[k++] = secondary[j++];\r\n        }\r\n        System.arraycopy(mergedArr,0,primary,l,r-l+1);\r\n        System.arraycopy(mergedArr2,0,secondary,l,r-l+1);\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699852",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c984",
		"title": "N-Queens and N-Knights",
		"postLinkTitle": "n-queens-and-n-knights",
		"desc": "//N-Queens\r\npublic class App {\r\n    public static void main(String[] args) throws Exception {\r\n        int n = 4;\r\n        nQueens(n);\r\n    }\r\n\r\n    static boolean[][] board;\r\n\r\n    private static void nQueens(int n) {\r\n        board = new boolean[n][n];\r\n        helper(0);\r\n    }\r\n\r\n    private static void helper(int n) {\r\n       // all n, queens are put\r\n        if (n == board.length) {\r\n            displayBoard();\r\n            return;\r\n        }\r\n        for (int i = 0; i < board.length; i++) {\r\n           // checking if we can put a queen at that pos\r\n            if (isSafe(n, i)) {\r\n                board[n][i] = true;\r\n                helper(n + 1);\r\n                board[n][i] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private static void displayBoard() {\r\n        for (int i = 0; i < board.length; i++) {\r\n            for (int j = 0; j < board.length; j++) {\r\n                System.out.print((board[i][j] ? 'Q' : '-') + \" \");\r\n            }\r\n            System.out.println();\r\n        }\r\n        System.out.println();\r\n    }\r\n\r\n    private static boolean isSafe(int r, int c) {\r\n        int i = r, j1 = c, j2 = c;\r\n        //checking if there exists a queen in\r\n        while (i >= 0) {\r\n            // top rows\r\n            if (board[i][c])\r\n                return false;\r\n            //top left diagonal\r\n            if (j1 >= 0 && board[i][j1--])\r\n                return false;\r\n            //top right diagonal\r\n            if (j2 < board.length && board[i][j2++])\r\n                return false;\r\n            i--;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n//N-Knights\r\npublic class App {\r\n    public static void main(String[] args) throws Exception {\r\n        int n = 4;\r\n        nKnights(n);\r\n    }\r\n\r\n    static boolean[][] board;\r\n\r\n    private static void nKnights(int n) {\r\n        board = new boolean[n][n];\r\n        helper(0, 0, n);\r\n    }\r\n\r\n    private static void helper(int r, int c, int cnt) {\r\n        if (r == board.length) {\r\n            return;\r\n        }\r\n        if (cnt == 0) {\r\n            displayBoard();\r\n            return;\r\n        }\r\n        if(c == board.length){\r\n            helper(r+1,0,cnt);\r\n            return;\r\n        }\r\n        if (isSafe(r, c)) {\r\n            board[r][c] = true;\r\n            helper(r, c + 1, cnt - 1);\r\n            board[r][c] = false;\r\n        }\r\n    }\r\n\r\n    private static void displayBoard() {\r\n        for (int i = 0; i < board.length; i++) {\r\n            for (int j = 0; j < board.length; j++) {\r\n                System.out.print((board[i][j] ? 'K' : '-') + \" \");\r\n            }\r\n            System.out.println();\r\n        }\r\n        System.out.println();\r\n    }\r\n\r\n    private static boolean isSafe(int r, int c) {\r\n        if (r - 2 >= 0 && c - 1 >= 0 && board[r - 2][c - 1]) {\r\n            return false;\r\n        }\r\n        if (r - 2 >= 0 && c + 1 < board.length && board[r - 2][c + 1]) {\r\n            return false;\r\n        }\r\n        if (r - 1 >= 0 && c + 2 < board.length && board[r - 1][c + 2]) {\r\n            return false;\r\n        }\r\n        if (r + 1 < board.length && c + 2 < board.length && board[r + 1][c + 2]) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699853",
		"__v": 0
	},
	{
		"_id": "621f4dcb91bb3ccf3447c986",
		"title": "Sudoku solver",
		"postLinkTitle": "sudoku-solver",
		"desc": "class Solution {\r\n    public void solveSudoku(char[][] board) {\r\n        helper(board,0, 0);\r\n    }\r\n\r\n    private static boolean helper(char[][] board,int r, int c) {\r\n        if (r == board.length) {\r\n            // for(char[] arr : board)\r\n            // System.out.println(Arrays.toString(arr));\r\n            // board is solved\r\n            return true;\r\n        }\r\n        // reached end of row\r\n        if (c == board.length) {\r\n            return helper(board,r + 1, 0);\r\n        }\r\n        // box is already filled\r\n        if (board[r][c] != '.') {\r\n            return helper(board,r, c + 1);\r\n        }\r\n        // putting numbers 1-9 and checking if it safe to put\r\n        for (int k = 1; k < 10; k++) {\r\n            char n = (char) (k+'0');\r\n            // if safe check for next box else check for next column\r\n            if (isSafe(board,r, c, n)) {\r\n                board[r][c] = n;\r\n                // if board solved return true or else backtrack\r\n                if(helper(board,r, c + 1)) return true;\r\n                board[r][c] = '.';\r\n            }\r\n        }\r\n        // board can't be solved with the previous combinations\r\n        return false;\r\n    }\r\n\r\n    private static boolean isSafe(char[][] board,int r, int c, char n) {\r\n        // checking the row and column\r\n        for (int i = 0; i < board.length; i++) {\r\n            if (board[r][i] == n || board[i][c] == n)\r\n                return false;\r\n        }\r\n        // cheking in that square\r\n        int i = (r / 3) * 3, j = (c / 3) * 3;\r\n        for (int k = 0; k < 3; k++) {\r\n            for (int l = 0; l < 3; l++) {\r\n                if (board[i + k][j + l] == n)\r\n                    return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646218699854",
		"__v": 0
	},
	{
		"_id": "6220c7801248e766b37d9044",
		"title": "Left, Right, Bottom and Top View of a Binary Tree",
		"postLinkTitle": "left-right-bottom-and-top-view-of-a-binary-tree",
		"desc": "// Left View and Right view\r\n//using pre order traversal\r\npublic class Solution{\r\n    static ArrayList<Integer> ans;\r\n    public static ArrayList<Integer> getLeftView(TreeNode<Integer> root) \r\n    {\r\n        ans = new ArrayList<>();\r\n        int level = 1;\r\n        helper(root,level);\r\n        return ans;\r\n    }\r\n    public static void helper(TreeNode<Integer> root, int level){ \r\n        // or we can maintain a variable maxlevel to store the max level\r\n        // if currLevel > maxlevel add that to ans\r\n        if(root == null) return;                                                     \r\n        if(level > ans.size()){\r\n            ans.add(root.data);\r\n        }\r\n       //left view\r\n        helper(root.left,level+1);\r\n        helper(root.right,level+1);\r\n        //right view\r\n        helper(root.right,level+1);\r\n        helper(root.left,level+1);\r\n    }\r\n}\r\n\r\n\r\n//using queue\r\npublic class Solution \r\n{\r\n    public static ArrayList<Integer> getLeftView(TreeNode<Integer> root) \r\n    {\r\n        \r\n        //    For storing the left view.\r\n        ArrayList<Integer> leftView =new ArrayList<Integer>();\r\n\r\n        if (root == null) return leftView;\r\n\r\n        //    Queue for doing level order traversal.\r\n        Queue<TreeNode<Integer>> level=new LinkedList<TreeNode<Integer>>();\r\n\r\n        //    Push the root in the queue.\r\n        level.add(root);\r\n        int leftMostNode=-1;\r\n\r\n        while (level.isEmpty() == false) {\r\n            \r\n            //    Get the size of the current level.\r\n            int queueSize = level.size();\r\n\r\n            //    Traverse all nodes of the current level.\r\n            for (int i = 0; i < queueSize; i++) {\r\n                //    Pop the node from the front of the queue.\r\n                TreeNode<Integer> curr = level.remove();\r\n\r\n                //    Add the left most node of the current level to the left view.\r\n               //left view\r\n                if (i == 0)  leftView.add(curr.data);\r\n                //right view\r\n               if (i == queueSize-1) rightView.add(curr.data);\r\n\r\n                //    Push the left child into the queue.\r\n                if (curr.left != null) level.add(curr.left);\r\n\r\n                //    Push the right child into the queue.\r\n                if (curr.right != null) level.add(curr.right);\r\n            }\r\n        }\r\n        return leftView;\r\n    }\r\n}\r\n\r\n\r\n// Bottom view and Top view using queue\r\n\r\nimport java.util.*;\r\n\r\npublic class Solution {\r\n    public class Pair {\r\n        BinaryTreeNode node;\r\n        int hd;\r\n        Pair(BinaryTreeNode node, int hd){\r\n            this.node = node;\r\n            this.hd = hd;\r\n        }\r\n    }\r\n    static ArrayList<Integer> ans;\r\n    static Map<Integer,Integer> map;\r\n    public static ArrayList<Integer> bottomView(BinaryTreeNode root) {\r\n         // Write your code here.\r\n        map = new TreeMap<>();\r\n        ans = new ArrayList<>();\r\n        Queue<Pair> q = new LinkedList<>();\r\n        q.add(new Solution().new Pair(root,0));\r\n        while(!q.isEmpty()){\r\n            int size = q.size();\r\n            for(int i=0;i<size;i++){\r\n                Pair curr = q.remove();\r\n                if(curr.node.left != null){\r\n                    q.add(new Solution().new Pair(curr.node.left,curr.hd-1));\r\n                }\r\n                if(curr.node.right != null){\r\n                    q.add(new Solution().new Pair(curr.node.right,curr.hd+1));\r\n                }\r\n                //Bottom view\r\n                map.put(curr.hd,curr.node.val);\r\n                //Top view\r\n                if(!map.containsKey(curr.hd)){\r\n                \tmap.put(curr.hd,curr.node.val);\r\n                }\r\n            }\r\n        }\r\n        for(int val : map.values()){\r\n            ans.add(val);\r\n        }\r\n        return ans;\r\n    }\r\n}\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646315392579",
		"__v": 0
	},
	{
		"_id": "622190f08aec28290a555286",
		"title": "Max Width of a Binary Tree",
		"postLinkTitle": "max-width-of-a-binary-tree",
		"desc": "public static int getMaxWidth(TreeNode root) {\r\n        if(root == null) return 0;\r\n        Queue<TreeNode> q = new LinkedList<>();\r\n        int maxWidth = -1;\r\n        q.add(root);\r\n        while(!q.isEmpty()){\r\n            int size = q.size();\r\n            maxWidth = Math.max(size,maxWidth);\r\n            for(int i=0;i<size;i++){\r\n                TreeNode curr = q.remove();\r\n                if(curr.left != null) q.add(curr.left);\r\n                if(curr.right != null) q.add(curr.right);\r\n            }\r\n        }\r\n        return maxWidth;\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1646366960752",
		"__v": 0
	},
	{
		"_id": "622b5591477d789be4e91248",
		"title": "Longest Palindromic Substring",
		"postLinkTitle": "longest-palindromic-substring",
		"desc": "// Expanding from centers approach\r\nclass Solution {\r\n    public String longestPalindrome(String s) {\r\n        String ans = \"\";\r\n        int n = s.length();\r\n        for(int i=0;i<n;i++){\r\n           // for odd length palindromic substrings\r\n            int p1 = i, p2 = i;\r\n            while(p1 >= 0 && p2 < n && s.charAt(p1) == s.charAt(p2)){\r\n                if(p2-p1+1 > ans.length())  \r\n                    ans = s.substring(p1,p2+1);\r\n                p1--;\r\n                p2++;\r\n            }\r\n             // for even length palindromic substrings\r\n            p1 = i; p2 = i+1;\r\n            while(p1 >= 0 && p2 < n && s.charAt(p1) == s.charAt(p2)){\r\n                if(p2-p1+1 > ans.length())  \r\n                    ans = s.substring(p1,p2+1);\r\n                p1--;\r\n                p2++;\r\n            }\r\n        }\r\n        return ans;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1647007121972",
		"__v": 0
	},
	{
		"_id": "622f4c10e8afc8278a2b0702",
		"title": "Enclosing Substring",
		"postLinkTitle": "enclosing-substring",
		"desc": "// finding the minimum or shortest length of the substring of string B such it contains all the characters of string A\r\npublic class Solution {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        int t = Integer.parseInt(in.nextLine());\r\n        while(t-- > 0){\r\n            String[] s = in.nextLine().split(\" \");\r\n            char[] a = s[0].toCharArray();\r\n            char[] b = s[1].toCharArray();\r\n            int[] freqA = new int[26];\r\n            int[] freqB = new int[26];\r\n           // storing the freq array of both strings\r\n            for(char c : a) freqA[c-'a']++;\r\n            // min length of substring that contains all chars of a is its length ( a string's length)\r\n            for(int i=0;i<a.length;i++) freqB[b[i]-'a']++;\r\n            int minLength = Integer.MAX_VALUE;\r\n            int p1=0,p2=a.length-1;\r\n            while(p2 < b.length){\r\n                while(valid(freqA,freqB)){\r\n                     // if the substring is valid ie contains all chars of a, then we update minLength and decrease the starting pointer p1 and update the freqB\r\n                    minLength = Math.min(minLength,p2-p1+1);\r\n                    freqB[b[p1++]-'a']--;\r\n                }\r\n                // if not valid move the end pointer p2 and update the freqB\r\n                p2++;\r\n                if(p2 < b.length)\r\n                    freqB[b[p2]-'a']++;\r\n            }\r\n            System.out.println(minLength == Integer.MAX_VALUE ? -1 : minLength);\r\n        }\r\n    }\r\n    public static boolean valid(int[] freqA,int[] freqB){\r\n        for(int i=0;i<26;i++){\r\n            if(freqA[i] > freqB[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1647266832462",
		"__v": 0
	},
	{
		"_id": "6231eb98af8cc1cb98a20722",
		"title": "Rabin Karp String Matching Algorithm",
		"postLinkTitle": "rabin-karp-string-matching-algorithm",
		"desc": "public class Solution {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        int t = Integer.parseInt(in.nextLine()), mod = 1000000007;\r\n        while(t-- > 0){\r\n            String[] s = in.nextLine().split(\" \");\r\n            char[] a = s[0].toCharArray();\r\n            char[] b = s[1].toCharArray();\r\n            int n = a.length, m = b.length;\r\n            long hA = 0, hB = 0;\r\n            long[] p = new long[m];\r\n            p[0] = 1;\r\n            hA = a[0]-'a';\r\n            hB = b[0]-'a';            \r\n            int i=1;\r\n            while(i<n){\r\n                p[i] = (p[i-1]*31)%mod;\r\n                hA = (hA + (a[i]-'a')*p[i])%mod;\r\n                hB = (hB + ((b[i]-'a')*p[i])%mod )%mod;\r\n                i++;\r\n            }\r\n            int cnt = 0;\r\n            if(hA == hB) cnt++;\r\n            while(i<m){\r\n                p[i] = (p[i-1]*31)%mod;\r\n                hA = (hA*31)%mod;\r\n                hB = (hB - ((b[i-n]-'a')*p[i-n])%mod + ((b[i]-'a')*p[i])%mod + mod)%mod;\r\n                if(hA == hB) cnt++;\r\n                i++;\r\n            }\r\n            System.out.println(cnt);\r\n        }\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1647438744167",
		"__v": 0
	},
	{
		"_id": "62341cbbad4dd3989db9c723",
		"title": "Longest Contiguous Subsequence",
		"postLinkTitle": "longest-contiguous-subsequence",
		"desc": "// Given an array, find the length of the longest subsequence whose elements can be re-arranged in a strictly increasing contiguous order. \r\n// The difference between 2 adjacent elements in the subsequence, after re-arrangement, should be exactly 1.\r\n\r\n// 10\r\n// 18 -33 31 33 30 -14 32 30 16 17\r\n// ans - 4( 33 31 30 32 )\r\n// sorting and removing duplicates solution\r\npublic class Solution {\r\n\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        int t = in.nextInt();\r\n        while(t-- > 0){\r\n            int n = in.nextInt();\r\n            Set<Integer> set = new TreeSet<>();\r\n            for(int i=0;i<n;i++){\r\n                set.add(in.nextInt());\r\n            }\r\n            int k=0;\r\n            int[] arr = new int[set.size()];\r\n            for(int i : set){\r\n                arr[k++] = i;\r\n            }\r\n            int i = 1, maxSize = 1;\r\n            while(i<arr.length){\r\n                int j=i;\r\n                while(j<arr.length && arr[j]-arr[j-1] == 1){\r\n                    j++;\r\n                }\r\n                maxSize = Math.max(j-i+1,maxSize);\r\n                i=j+1;\r\n            }\r\n            System.out.println(maxSize);\r\n        }\r\n    }\r\n}\r\n\r\n// using set\r\npublic class Solution {\r\n\r\n    public static void main(String[] args) throws Exception {\r\n        Scanner in = new Scanner(System.in);\r\n        int t = in.nextInt();\r\n        while(t-- > 0){\r\n            int n = in.nextInt();\r\n            Set<Integer> set = new HashSet<>();\r\n            for(int i=0;i<n;i++)    set.add(in.nextInt());\r\n            int ans = 1;\r\n            for(int i : set){\r\n               // there exists another number which is smaller than curr num\r\n               if(set.contains(i-1)) continue;\r\n                int j = i;\r\n                while(set.contains(j)){\r\n                    j++;\r\n                }\r\n                ans = Math.max(ans,j-i);\r\n            }\r\n            System.out.println(ans);\r\n        }\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1647582395806",
		"__v": 0
	},
	{
		"_id": "623427ff417f0f8a2c7d8d8d",
		"title": "Frequency Sort",
		"postLinkTitle": "frequency-sort",
		"desc": "// You are given an array of integers. Sort them by frequency. In case 2 elements have the same frequency, print the smaller element first.\r\n\r\n// 4 -2 10 12 -8 4 -> -8 -2 10 12 4 4 \r\n// 176 -272 -272 -45 269 -327 -945 176 -> -945 -327 -45 269 -272 -272 176 176 \r\n\r\npublic class Solution {\r\n    public class Pair{\r\n        int key, value;\r\n        Pair(int key,int value){\r\n            this.key = key;\r\n            this.value = value;\r\n        }\r\n        public String toString(){\r\n            return this.key + \" \" + this.value + \" \";\r\n        }\r\n    }\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        int t = in.nextInt();\r\n        while(t-- > 0){\r\n            int n = in.nextInt();\r\n            Map<Integer,Integer> map = new HashMap<>();\r\n            for(int i=0;i<n;i++){\r\n                int ele = in.nextInt();\r\n                map.put(ele,map.getOrDefault(ele,0)+1);\r\n            }\r\n            Solution.Pair[] arr = new Solution.Pair[map.size()];\r\n            int k = 0;\r\n            for(Map.Entry<Integer,Integer> e : map.entrySet()){\r\n                arr[k++] = new Solution().new Pair(e.getKey(),e.getValue());\r\n            }\r\n            Arrays.sort(arr, new Comparator<Solution.Pair>(){\r\n                public int compare(Pair p1, Pair p2){\r\n                    int c = Integer.compare(p1.value, p2.value);\r\n                    if(c != 0) return c;\r\n                    c = Integer.compare(p1.key,p2.key);\r\n                    return c;\r\n                }\r\n            });\r\n            for(Pair p : arr){\r\n                for(int j=0;j<p.value;j++){\r\n                    System.out.print(p.key + \" \");\r\n                }\r\n            }\r\n            System.out.println();\r\n        }\r\n    }\r\n}\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1647585279956",
		"__v": 0
	},
	{
		"_id": "6238823848930d383327c0d7",
		"title": "Palindromic LinkedList",
		"postLinkTitle": "palindromic-linked-list",
		"desc": "//https://www.youtube.com/watch?v=ee-DuKtRNGw&list=PLUcsbZa0qzu3yNzzAxgvSgRobdUUJvz7p&index=38&ab_channel=AnujBhaiya\r\npublic class Solution {\r\n    public int lPalin(ListNode head) {\r\n        if(head == null || head.next == null) return 1;\r\n        ListNode middle = findMiddle(head);\r\n        // reverse  the list from middle\r\n        // revList returns last node\r\n        ListNode last = revList(middle);\r\n        ListNode start = head;\r\n        while(last != null && start.val == last.val){\r\n            last = last.next;\r\n            start = start.next;\r\n        }\r\n        return last == null ? 1 : 0;\r\n    }\r\n    public ListNode findMiddle(ListNode head){\r\n        ListNode fast = head, slow = head;\r\n        while(fast != null && fast.next != null){\r\n            fast = fast.next.next;\r\n            slow = slow.next;\r\n        }\r\n        return slow;\r\n    }\r\n    public ListNode revList(ListNode head){\r\n        if(head.next == null){\r\n            return head;\r\n        }\r\n        ListNode rev = revList(head.next);\r\n        head.next.next = head;\r\n        head.next = null;\r\n        return rev;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1647870520636",
		"__v": 0
	},
	{
		"_id": "6238839448930d383327c0e2",
		"title": "LinkedList Cycle related problems",
		"postLinkTitle": "linked-list-cycle-related-problems",
		"desc": "// https://www.youtube.com/watch?v=jcZtMh_jov0&list=PLUcsbZa0qzu3yNzzAxgvSgRobdUUJvz7p&index=39&ab_channel=AnujBhaiya\r\npublic class Solution {\r\n    public ListNode detectCycle(ListNode head) {\r\n        ListNode slow = head, fast = head;\r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n            if(slow == fast) break;\r\n        }\r\n        // there is no cycle in list\r\n        if(fast == null || fast.next == null) return null;\r\n        ListNode start = head, meet = slow;\r\n        while(start != meet){\r\n           // prev = meet;\r\n            meet = meet.next;\r\n            start = start.next;\r\n        }\r\n       // meet is node where cycle in list starts\r\n       // we can maintain a prev node to remove cycle in the list\r\n       // prev.next = null\r\n        return meet;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1647870868254",
		"__v": 0
	},
	{
		"_id": "623b18b64c7340eec4f9b72d",
		"title": "Largest Area of a rectangle in Histogram problem",
		"postLinkTitle": "largest-area-of-a-rectangle-in-histogram-problem",
		"desc": "// https://leetcode.com/problems/largest-rectangle-in-histogram/\r\n// using stack\r\nclass Solution {\r\n    public int largestRectangleArea(int[] heights) {\r\n        int n = heights.length;\r\n       // gives indices which are smaller and on the left side of each element\r\n        int[] leftMin = getLeftMin(heights,n);\r\n       // gives indices which are smaller and on the right side of each element\r\n        int[] rightMin = getRightMin(heights,n);\r\n        int maxArea = 0;\r\n        for(int i=0;i<n;i++){\r\n            maxArea = Math.max(maxArea, (rightMin[i]-leftMin[i]-1) * heights[i]);\r\n        }\r\n        return maxArea;\r\n    }\r\n    \r\n    public int[] getRightMin(int[] arr,int n){\r\n        Stack<Integer> st = new Stack<>();\r\n        int[] rightMin = new int[n];\r\n        for(int i=n-1;i>=0;i--){\r\n           // removing elems >= cur until we get elem < cur\r\n            while(!st.isEmpty() && arr[st.peek()] >= arr[i]){\r\n                st.pop();\r\n            }\r\n            // if no elem is found on right side which is smaller, then we put 'n' bcz that height extends up to the right end\r\n            rightMin[i] = st.isEmpty() ? n : st.peek();\r\n            st.push(i);\r\n        }\r\n        return rightMin;\r\n    }\r\n    \r\n    public int[] getLeftMin(int[] arr,int n){\r\n        Stack<Integer> st = new Stack<>();\r\n        int[] leftMin = new int[n];\r\n        for(int i=0;i<n;i++){\r\n           // removing elems >= cur until we get elem < cur\r\n            while(!st.isEmpty() && arr[st.peek()] >= arr[i]){\r\n                st.pop();\r\n            }\r\n            // if no elem is found on left side which is smaller, then we put '-1' bcz that height extends up to the left end\r\n            leftMin[i] = st.isEmpty() ? -1 : st.peek();\r\n            st.push(i);\r\n        }\r\n        return leftMin;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648040118419",
		"__v": 0
	},
	{
		"_id": "623b4753b5bb5a67108b3b47",
		"title": "Min Stack and Max Stack",
		"postLinkTitle": "min-stack-and-max-stack",
		"desc": "// https://leetcode.com/problems/min-stack/submissions/\r\n\r\nclass MinStack {\r\n    Stack<Integer> stack;\r\n    Stack<Integer> minStack;\r\n    public MinStack() {\r\n        stack = new Stack<>();\r\n        minStack = new Stack<>();\r\n    }\r\n    \r\n    public void push(int val) {\r\n        stack.push(val);\r\n        if(minStack.isEmpty()){\r\n            minStack.push(val);\r\n            return;\r\n        }\r\n        if(minStack.peek().compareTo(val) >= 0){\r\n            minStack.push(val);\r\n        }\r\n    }\r\n    \r\n    public void pop() {\r\n        if(stack.peek().equals(minStack.peek())){\r\n            stack.pop();\r\n            minStack.pop();\r\n        }else{\r\n            stack.pop();            \r\n        }\r\n    }\r\n    \r\n    public int top() {\r\n        return stack.peek();\r\n    }\r\n    \r\n    public int getMin() {\r\n        return minStack.peek();\r\n    }\r\n}\r\n\r\n// maxstack\r\nclass MaxStack {\r\n    Stack<Integer> stack;\r\n    Stack<Integer> maxStack;\r\n    public MinStack() {\r\n        stack = new Stack<>();\r\n        maxStack= new Stack<>();\r\n    }\r\n    \r\n    public void push(int val) {\r\n        stack.push(val);\r\n        if(maxStack.isEmpty()){\r\n            maxStack.push(val);\r\n            return;\r\n        }\r\n        if(maxStack.peek().compareTo(val) <= 0){\r\n            maxStack.push(val);\r\n        }\r\n    }\r\n    \r\n    public void pop() {\r\n        if(stack.peek().equals(maxStack.peek())){\r\n            stack.pop();\r\n            maxStack.pop();\r\n        }else{\r\n            stack.pop();            \r\n        }\r\n    }\r\n    \r\n    public int top() {\r\n        return stack.peek();\r\n    }\r\n    \r\n    public int getMin() {\r\n        return maxStack.peek();\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648052051156",
		"__v": 0
	},
	{
		"_id": "623c6b8c1c1da62b30558d08",
		"title": "Implementing Queue using Stack",
		"postLinkTitle": "implementing-queue-using-stack",
		"desc": "class MyQueue {\r\n    Stack<Integer> s1;\r\n    Stack<Integer> s2;\r\n    public MyQueue() {\r\n        s1 = new Stack<>();\r\n        s2 = new Stack<>();\r\n    }\r\n    \r\n    public void push(int x) {\r\n        s1.push(x);\r\n    }\r\n    \r\n    public int pop() {\r\n        if(s2.isEmpty()){\r\n            while(!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.pop();\r\n    }\r\n    \r\n    public int peek() {\r\n        if(s2.isEmpty()){\r\n            while(!s1.isEmpty()){\r\n                s2.push(s1.pop());\r\n            }\r\n        }\r\n        return s2.peek();\r\n    }\r\n    \r\n    public boolean empty() {\r\n        return s1.isEmpty() && s2.isEmpty();\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648126860699",
		"__v": 0
	},
	{
		"_id": "62445c45e9f09a39ce1b3837",
		"title": "Sliding Window Maximum",
		"postLinkTitle": "sliding-window-maximum",
		"desc": "class Solution {\r\n    public int[] maxSlidingWindow(int[] arr, int k) {\r\n        Deque<Integer> dq = new LinkedList<>();\r\n        int i = 0, n = arr.length;            \r\n        while(i<k){\r\n            while(!dq.isEmpty() && arr[i] > arr[dq.peekLast()])\r\n                dq.removeLast();\r\n            dq.addLast(i);\r\n            i++;\r\n        }\r\n        int[] maxWindow = new int[n-k+1];\r\n        maxWindow[i-k] = arr[dq.peek()];\r\n        while(i<n){\r\n            if(arr[i-k] == arr[dq.peek()]) dq.removeFirst();\r\n            while(!dq.isEmpty() && arr[i] > arr[dq.peekLast()])\r\n                dq.removeLast();\r\n            dq.addLast(i);\r\n            i++;\r\n            maxWindow[i-k] = arr[dq.peek()];\r\n        }\r\n        return maxWindow;\r\n    }\r\n}\r\n\r\npublic int[] maxSlidingWindow(int[] arr, int k) {\t\r\n\t\tint n = arr.length;\r\n\t\tint[] maxInWindow = new int[n-k+1];\r\n\t\tDeque<Integer> dq = new ArrayDeque<>();\r\n\t\tfor (int i = 0; i < arr.length; i++) {\r\n\t\t\t// remove numbers out of range k\r\n\t\t\tif(!dq.isEmpty() && dq.peek() < i - k + 1) {\r\n\t\t\t\tdq.removeFirst();\r\n\t\t\t}\r\n\t\t\t// remove smaller numbers in k range as they are useless\r\n\t\t\twhile (!dq.isEmpty() && arr[dq.peekLast()] < arr[i]) {\r\n\t\t\t\tdq.removeLast();\r\n\t\t\t}\r\n\t\t\t// dq contains index... r contains content\r\n\t\t\tq.addLast(i);\r\n\t\t\tif (i >= k - 1) {\r\n\t\t\t\tmaxInWindow[i-k-1] = arr[dq.peek()];\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn maxInWindow;\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648647237726",
		"__v": 0
	},
	{
		"_id": "6244714eaad5fef053792f91",
		"title": "Clone a LinkedList with a random pointer",
		"postLinkTitle": "clone-a-linked-list-with-a-random-pointer",
		"desc": "       public Node copyRandomList(Node head) {\r\n        if(head == null) return null;\r\n        Node temp = head;\r\n        while(temp != null){\r\n            Node nn = new Node(temp.val);\r\n            nn.next = temp.next;\r\n            temp.next = nn;\r\n            temp = temp.next.next;\r\n        }\r\n        Node copyHead = head.next, p1 = head, p2 = copyHead;\r\n        while(p1 != null){\r\n            p2.random = p1.random == null ? null : p1.random.next;\r\n            p1 = p1.next.next;\r\n            p2 = p2.next == null ? null : p2.next.next;\r\n        }\r\n        p1 = head; p2 = copyHead;\r\n        while(p1 != null){\r\n            p1.next = p1.next.next;\r\n            p1 = p1.next;\r\n            p2.next = p2.next == null ? null : p2.next.next;\r\n            p2 = p2.next;\r\n        }\r\n        return copyHead;\r\n    }\r\n\r\n// using map\r\n    public Node copyRandomList(Node head) {\r\n        if(head == null) return null;\r\n        Map<Node,Node> map = new HashMap<>();\r\n        Node temp = head;\r\n        while(temp != null){\r\n            Node nn = new Node(temp.val);\r\n            map.put(temp,nn);\r\n            temp = temp.next;\r\n        }\r\n        temp = head;\r\n        while(temp != null){\r\n            map.get(temp).next = map.get(temp.next);\r\n            map.get(temp).random = map.get(temp.random);\r\n            temp = temp.next;\r\n        }\r\n        return map.get(head); // copyHead\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648652622411",
		"__v": 0
	},
	{
		"_id": "62447c71d07aa8297706d7f6",
		"title": "Merge sort LinkedList",
		"postLinkTitle": "merge-sort-linked-list",
		"desc": "    public ListNode sortList(ListNode head) {\r\n        if(head == null || head.next == null) return head;\r\n        ListNode mid = findMid(head);\r\n        ListNode rightHead = mid.next;\r\n        mid.next = null;\r\n        return merge(sortList(head), sortList(rightHead));\r\n    }\r\n    public ListNode findMid(ListNode head){\r\n        if(head == null || head.next == null) return head;\r\n        ListNode slow = head, fast = head.next.next;\r\n        while(fast != null && fast.next != null){\r\n            slow = slow.next;\r\n            fast = fast.next.next;\r\n        }\r\n        return slow;\r\n    }\r\n    public ListNode merge(ListNode h1, ListNode h2){\r\n        if(h1 == null) return h2;\r\n        if(h2 == null) return h1;\r\n        if(h1.val < h2.val){\r\n            h1.next = merge(h1.next,h2);\r\n            return h1;\r\n        }\r\n        h2.next = merge(h1,h2.next);\r\n        return h2;\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648655473741",
		"__v": 0
	},
	{
		"_id": "6244803bd07aa8297706d80f",
		"title": "Merge K sorted Lists(LL)",
		"postLinkTitle": "merge-k-sorted-lists-ll",
		"desc": "public ListNode mergeKLists(ListNode[] lists) {\r\n        if(lists.length == 0) return null;\r\n        int minNodeIndex = 0, nullCnt = 0;\r\n        for(int i=0;i<lists.length;i++){\r\n            if(lists[i] == null){\r\n                nullCnt++;\r\n                continue;\r\n            }\r\n            if(lists[minNodeIndex] == null || lists[minNodeIndex].val > lists[i].val){\r\n                minNodeIndex = i;\r\n            }\r\n        }\r\n        if(nullCnt == lists.length) return null;\r\n        ListNode head = lists[minNodeIndex];\r\n        lists[minNodeIndex] = lists[minNodeIndex].next;\r\n        head.next = mergeKLists(lists);\r\n        return head;\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648656443482",
		"__v": 0
	},
	{
		"_id": "6247e405b4b9284e3fd294a7",
		"title": "Construct Binary Tree from Preorder and Inorder Traversal",
		"postLinkTitle": "construct-binary-tree-from-preorder-and-inorder-traversal",
		"desc": "class Solution {\r\n   // for getting the roots one by one in preorder\r\n    int preorderIndex = 0;\r\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\r\n        return helper(preorder, inorder, 0, preorder.length-1);\r\n    }\r\n    TreeNode helper(int[] pre, int[] in, int s,int e){\r\n        if(s > e) return null;\r\n        // getting the pos of root (i.e using preorderIndex in preorder array) in inorder array gives its left and right subtree\r\n        int inorderIndex = find(in,s,e,pre[preorderIndex]);\r\n        TreeNode root = new TreeNode(pre[preorderIndex]);\r\n        // for next root in preorder\r\n        preorderIndex++;\r\n       // left subtree\r\n        root.left = helper(pre,in,s,inorderIndex-1);\r\n       // right subtree\r\n        root.right = helper(pre,in,inorderIndex+1,e);\r\n        return root;\r\n    }\r\n    int find(int[] arr, int s, int e, int key){\r\n        int i=s;\r\n        for(;i<=e;i++){\r\n            if(arr[i] == key) break;\r\n        }\r\n        return i;\r\n    }\r\n}\r\n\r\n// printing postorder using preorder and inorder traversal\r\nclass Solution {\r\n    int preorderIndex = 0;\r\n    public void printPreorder(int[] preorder, int[] inorder) {\r\n        helper(preorder, inorder, 0, preorder.length-1);\r\n    }\r\n    void helper(int[] pre, int[] in, int s,int e){\r\n        if(s > e) return;\r\n        int inorderIndex = find(in,s,e,pre[preorderIndex]);\r\n        int cur = pre[preorderIndex]);\r\n        preorderIndex++;\r\n        helper(pre,in,s,inorderIndex-1);\r\n        helper(pre,in,inorderIndex+1,e);\r\n        print(curr);\r\n    }\r\n    int find(int[] arr, int s, int e, int key){\r\n        int i=s;\r\n        for(;i<=e;i++){\r\n            if(arr[i] == key) break;\r\n        }\r\n        return i;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648878597705",
		"__v": 0
	},
	{
		"_id": "6247e9a3b4b9284e3fd294b2",
		"title": "Construct Binary Tree from Inorder and Postorder Traversal",
		"postLinkTitle": "construct-binary-tree-from-inorder-and-postorder-traversal",
		"desc": "// same as Construct Binary Tree from Preorder and Inorder Traversal but we traverse postorder from backside and next elem after root will be right node in postorder\r\nclass Solution {\r\n    int postorderIndex;\r\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\r\n        postorderIndex =  postorder.length-1;\r\n        return helper(postorder, inorder, 0, postorder.length-1);\r\n    }\r\n    TreeNode helper(int[] post, int[] in, int s,int e){\r\n        if(s > e) return null;\r\n        int inorderIndex = find(in,s,e,post[postorderIndex]);\r\n        TreeNode root = new TreeNode(post[postorderIndex]);\r\n        postorderIndex--;\r\n        root.right = helper(post,in,inorderIndex+1,e);\r\n        root.left = helper(post,in,s,inorderIndex-1);\r\n        return root;\r\n    }\r\n    int find(int[] arr, int s, int e, int key){\r\n        int i=s;\r\n        for(;i<=e;i++){\r\n            if(arr[i] == key) break;\r\n        }\r\n        return i;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1648880035347",
		"__v": 0
	},
	{
		"_id": "624af03a1f0f6cc938378f7c",
		"title": "Binary Tree Maximum Path Sum",
		"postLinkTitle": "binary-tree-maximum-path-sum",
		"desc": "class Solution {\r\n    int max = Integer.MIN_VALUE;\r\n    public int maxPathSum(TreeNode root) {\r\n        helper(root);\r\n        return max;\r\n    }\r\n    //*max sum path may not include root node so we have to check for every node\r\n    int helper(TreeNode root){\r\n        if(root == null) return 0;\r\n        // maxing with 0 bcz we may not include that path sum if it is -ve.\r\n        int l = Math.max(0,helper(root.left));\r\n        int r = Math.max(0,helper(root.right));\r\n       // curr goes to higher recursion or nodes as a path sum\r\n       // which includes max sum b/w left and right subtree\r\n        int curr = root.val + Math.max(l,r);\r\n       // max gets updated for every node\r\n       // max = maxPathSum(left) + root + maxPathSum(right)\r\n        max = Math.max(max,root.val + l + r);\r\n        return curr;\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1649078330447",
		"__v": 0
	},
	{
		"_id": "624f0219a22007b255aa5480",
		"title": "Lowest Common Ancestor",
		"postLinkTitle": "lowest-common-ancestor",
		"desc": "// BST\r\npublic TreeNode LCA(TreeNode root, TreeNode p, TreeNode q) {\r\n        // both are on left side\r\n        if(root.val > p.val && root.val > q.val)    return LCA(root.left, p, q);\r\n        // both are on right side\r\n        if(root.val < p.val && root.val < q.val)    return LCA(root.right, p, q);\r\n        // else (root.val == p.val || root.val == q.val) , root.val > min(p,q) && root.val < max(p,q) i.e p, q are on either sides of node\r\n        return root;\r\n}\r\n\r\n//Binary Tree\r\npublic TreeNode LCA(TreeNode root, TreeNode p, TreeNode q) {\r\n       // cur node is null or we found one of p, q\r\n        if (root == null || root == p || root == q) return root;\r\n        TreeNode l = LCA(root.left,p,q);\r\n        TreeNode r = LCA(root.right,p,q);\r\n        // p, q are on either sides of node\r\n        if(l != null && r != null) return root;\r\n        return r == null ? l : r;\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1649345049490",
		"__v": 0
	},
	{
		"_id": "6250452c45cd895425b1f2ed",
		"title": "Nodes At A Distance K Problem",
		"postLinkTitle": "nodes-at-a-distance-k-problem",
		"desc": "// BST\r\n    int cnt = 0;\r\n    public static int findX(Node root, int s, int k){\r\n       // found the node incr cnt by no. of nodes at dist k\r\n        if(root.data == s){\r\n            cnt += noOfNodesAtDistK(root,k);\r\n            return 1;\r\n        }\r\n        // req node is on left sub tree\r\n        if(s < root.data){\r\n            int l = findX(root.left,s,k);\r\n            // ancestor at a dist k\r\n            if(l == k) cnt++;\r\n            // no of nodes at dist k-l-1 on opp side of s\r\n            cnt += noOfNodesAtDistK(root.right,k-l-1);\r\n            return l+1;\r\n        }\r\n        int r = findX(root.right,s,k);\r\n        if(r == k) cnt++;\r\n        cnt += noOfNodesAtDistK(root.left,k-r-1);\r\n        return r+1;\r\n    }\r\n    // calc the no. of nodes at a dist k below the given the node\r\n    public static int noOfNodesAtDistK(Node root, int k){\r\n        if(root == null || k < 0) return 0;\r\n        if(k == 0) return 1;\r\n        return noOfNodesAtDistK(root.left,k-1) + noOfNodesAtDistK(root.right,k-1);\r\n    }\r\n\r\n// Binary Tree\r\nclass Solution {\r\n    List<Integer> ans;\r\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\r\n        ans = new ArrayList<>();\r\n        findTargetNode(root,target,k);\r\n        return ans;\r\n    }\r\n    public int findTargetNode(TreeNode root, TreeNode target, int k){\r\n        if(root == null) return 0;\r\n        if(root == target){\r\n            nodesAtDistK(root,k);\r\n            return 1;\r\n        }\r\n        int l = findTargetNode(root.left,target,k);\r\n        if(l > 0){\r\n            if(l == k) ans.add(root.val);\r\n            else if(l < k)  nodesAtDistK(root.right,k-l-1);\r\n            return l+1;\r\n        }\r\n        int r = findTargetNode(root.right,target,k);\r\n        if(r > 0){\r\n            if(r == k) ans.add(root.val);\r\n            else if(r < k) nodesAtDistK(root.left,k-r-1);\r\n            return r+1;\r\n        }\r\n        return 0;\r\n    }\r\n    public void nodesAtDistK(TreeNode root, int k){\r\n        if(root == null || k<0) return;\r\n        if(k == 0){\r\n            ans.add(root.val);\r\n            return;\r\n        }\r\n        nodesAtDistK(root.left, k-1);\r\n        nodesAtDistK(root.right, k-1);\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1649427756503",
		"__v": 0
	},
	{
		"_id": "62543cb302269ae96a2c5881",
		"title": "Vertical Order Traversal of a Binary Tree",
		"postLinkTitle": "vertical-order-traversal-of-a-binary-tree",
		"desc": "public class Solution {\r\n    class Pair{\r\n        TreeNode root;\r\n        int hd;\r\n        Pair(TreeNode root, int hd){\r\n            this.root = root;\r\n            this.hd = hd;\r\n        }\r\n    }\r\n    Map<Integer,List<Integer>> map;\r\n    public int[][] verticalOrderTraversal(TreeNode root) {\r\n        map = new TreeMap<>();\r\n        fillMap(root);\r\n        int[][] ans = new int[map.size()][];\r\n        int i = 0;\r\n        for(List<Integer> list : map.values()){\r\n            ans[i] = new int[list.size()];\r\n            for(int j=0;j<list.size();j++) ans[i][j] = list.get(j);\r\n            i++;\r\n        }\r\n        return ans;\r\n    }\r\n\r\n    public void fillMap(TreeNode root){\r\n        if(root == null) return;\r\n        Queue<Pair> q = new LinkedList<>();\r\n        q.offer(new Pair(root,0));\r\n        while(!q.isEmpty()){\r\n            Pair cur = q.poll();\r\n            if(!map.containsKey(cur.hd)){\r\n                map.put(cur.hd, new ArrayList<Integer>());\r\n            }\r\n            map.get(cur.hd).add(cur.root.val);\r\n            if(cur.root.left != null) q.offer(new Pair(cur.root.left,cur.hd-1));\r\n            if(cur.root.right != null) q.offer(new Pair(cur.root.right,cur.hd+1));\r\n        }\r\n    }\r\n}\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1649687731282",
		"__v": 0
	},
	{
		"_id": "62568a223bcc8f5caf79d0c4",
		"title": "Boundary Treversal Of A Tree",
		"postLinkTitle": "boundary-treversal-of-a-tree",
		"desc": "import java.util.*;\r\n\r\npublic class Solution {\r\n\tstatic ArrayList<Integer> ans;\r\n\tpublic static ArrayList<Integer> traverseBoundary(TreeNode root){\r\n\t\tif(root == null) return new ArrayList<Integer>();\r\n\t\tans = new ArrayList<>();\r\n\t\tans.add(root.data);\r\n\t\tif(isLeaf(root)) return ans;\r\n\t\taddLeftBoundary(root.left);\r\n\t\taddLeaves(root);\r\n\t\taddRightBoundary(root.right);\r\n\t\treturn ans;\r\n\t}\r\n\t\r\n\tpublic static boolean isLeaf(TreeNode root){ return root.left == null && root.right == null; }\r\n\t\r\n        // adding left most or starting node at each level\r\n\tpublic static void addLeftBoundary(TreeNode root){\r\n\t\tif(root == null || isLeaf(root)) return;\r\n\t\tans.add(root.data);\r\n\t\tif(root.left != null)\taddLeftBoundary(root.left);\r\n\t\telse addLeftBoundary(root.right);\r\n\t}\r\n\t\r\n        // adding right most or last node at each level\r\n\tpublic static void addRightBoundary(TreeNode root){\r\n\t\tif(root == null || isLeaf(root)) return;\r\n\t\tif(root.right != null)\taddRightBoundary(root.right);\r\n\t\telse addRightBoundary(root.left);\r\n\t\tans.add(root.data);\r\n\t}\r\n\t\r\n\tpublic static void addLeaves(TreeNode root){\r\n\t\tif(root == null) return;\r\n\t\tif(isLeaf(root)){\r\n\t\t\tans.add(root.data);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\taddLeaves(root.left);\r\n\t\taddLeaves(root.right);\r\n\t}\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1649838626043",
		"__v": 0
	},
	{
		"_id": "6258232cd1a094980312dfeb",
		"title": "Basic Euclidean Algorithm for GCD",
		"postLinkTitle": "basic-euclidean-algorithm-for-gcd",
		"desc": "//Basic Euclidean Algorithm for GCD \r\n//The algorithm is based on the below facts. \r\n\r\n//1. If we subtract a smaller number from a larger one (we reduce a larger number), GCD doesnt change. \r\n// So if we keep subtracting repeatedly the larger of two, we end up with GCD.\r\n//2. Now instead of subtraction, if we divide the smaller number, the algorithm stops when we find the remainder 0.\r\n\r\npublic static int gcd(int a, int b){\r\n        if (a == 0) return b;\r\n        return gcd(b%a, a);\r\n}\r\n\r\n// Time Complexity: O(Log max(a, b))  ",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1649943340264",
		"__v": 0
	},
	{
		"_id": "6258299dd1a094980312dfef",
		"title": "Sieve of Eratosthenes",
		"postLinkTitle": "sieve-of-eratosthenes",
		"desc": "//Given a number n, print all primes smaller than or equal to n. It is also given that n is a small number. \r\n//The sieve of Eratosthenes is one of the most efficient ways to find all primes smaller than n when n is smaller than 10 million or so\r\n\r\nvoid sieveOfEratosthenes(int n){\r\n        boolean prime[] = new boolean[n + 1];\r\n        for (int i = 0; i <= n; i++)\r\n            prime[i] = true;\r\n \r\n        for (int p = 2; p * p <= n; p++){\r\n            if (prime[p] == true){\r\n                // Update all multiples of p\r\n                for (int i = p * p; i <= n; i += p)\r\n                    prime[i] = false;\r\n            }\r\n        }\r\n        for (int i = 2; i <= n; i++){\r\n            if (prime[i] == true)\r\n                System.out.print(i + \" \");\r\n        }\r\n}\r\n// Time Complexity: O(n*log(log(n)))\r\n// Auxiliary Space: O(n)\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1649944989286",
		"__v": 0
	},
	{
		"_id": "6259792f743d8444cecc39f1",
		"title": "Edit Distance Problem",
		"postLinkTitle": "edit-distance-problem",
		"desc": "// Given two strings A and B, find the minimum number of steps required to convert A to B. (each operation is counted as 1 step.)\r\n// You have the following 3 operations permitted on a word:\r\n// Insert a character\r\n// Delete a character\r\n// Replace a character\r\n\r\npublic class Solution {\r\n    int[][] dp;\r\n    public int minDistance(String A, String B) {\r\n        dp = new int[A.length()+1][B.length()+1];\r\n        for(int[] arr : dp) Arrays.fill(arr,-1);\r\n        return helper(A,B,A.length(), B.length());\r\n    }\r\n    public int helper(String A, String B, int i, int j){\r\n        // If first string is empty, the only option is to\r\n        // insert all characters of second string into first\r\n        if (i == 0) return j;\r\n \r\n        // If second string is empty, the only option is to\r\n        // remove all characters of first string\r\n        if (j == 0) return i;\r\n\r\n        // if(i == 0 || j == 0) return i+j;\r\n\r\n        if(dp[i][j] != -1) return dp[i][j];\r\n       \r\n       // If last characters of two strings are same,\r\n       // nothing much to do. Ignore last characters and\r\n       // get count for remaining strings. => 0 operations are required\r\n       if(A.charAt(i-1) == B.charAt(j-1)) return dp[i][j] = helper(A,B,i-1,j-1);\r\n\r\n       // If last characters are not same, consider all\r\n       // three operations on last character of first\r\n       // string, recursively compute minimum cost for all\r\n       // three operations and take minimum of three\r\n       // values. => we can do add, remove or replace a char at pos which will cost 1\r\n       //                               insert                    remove            replace     \r\n        return dp[i][j] = 1 + min(helper(A,B,i,j-1), helper(A,B,i-1,j), helper(A,B,i-1,j-1));\r\n    }\r\n}\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1650030895161",
		"__v": 0
	},
	{
		"_id": "626782b02349f4c0822b0397",
		"title": "Coin Sum Problem using only one O(N) Extra Space",
		"postLinkTitle": "coin-sum-problem-using-only-one-o-n-extra-space",
		"desc": "public class Solution {\r\n    public int coinchange2(int[] coins, int amount) {\r\n    int[] dp = new int[amount + 1];\r\n    dp[0] = 1;\r\n    for (int coin : coins) {\r\n      for (int x = coin; x < amount + 1; ++x) {\r\n        dp[x] = (dp[x] + dp[x - coin]) % 1000007\r\n      }\r\n    }\r\n    return dp[amount];\r\n    }\r\n}",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1650950832405",
		"__v": 0
	},
	{
		"_id": "6268fac30cbcb8062298d97f",
		"title": "Interleaving Strings",
		"postLinkTitle": "interleaving-strings",
		"desc": "    \r\n// Given A, B, C, find whether C is formed by the interleaving of A and B.\r\n\r\n    static Boolean[][] dp;\r\n\r\n    public static int isInterleave(String A, String B, String C) {\r\n        dp = new Boolean[A.length() + 1][B.length() + 1];\r\n        for (Boolean[] arr : dp)\r\n            Arrays.fill(arr, null);\r\n        Boolean ans = helper(A, B, C, A.length(), B.length(), C.length());\r\n        // for(Boolean[] arr : dp)\r\n        //    System.out.println(Arrays.toString(arr));\r\n        return ans ? 1 : 0;\r\n    }\r\n\r\n    public static Boolean helper(String a, String b, String c, int i, int j, int k) {\r\n\r\n        if(dp[i][j] != null) return dp[i][j];\r\n\r\n        // a string have been found in c so => remaining of c should be equal to b\r\n        if (i == 0) {\r\n            return dp[i][j] = b.substring(0, j).equals(c.substring(0, k));\r\n        }\r\n\r\n       // b string have been found => c should be equal to a\r\n        if (j == 0) {\r\n            return dp[i][j] = a.substring(0, i).equals(c.substring(0, k));\r\n        }\r\n\r\n        // if one of the char in a or b is matching with c => we are on the right path\r\n        if (a.charAt(i - 1) == c.charAt(k - 1)) return dp[i][j] = helper(a, b, c, i - 1, j, k - 1);\r\n        if (b.charAt(j - 1) == c.charAt(k - 1)) return dp[i][j] = helper(a, b, c, i, j - 1, k - 1);\r\n\r\n       // if both are matching => we have to check for both the matching conditions separately\r\n        if (a.charAt(i - 1) == c.charAt(k - 1) && b.charAt(j - 1) == c.charAt(k - 1)) {\r\n            return dp[i][j] = helper(a, b, c, i - 1, j, k - 1) || helper(a, b, c, i, j - 1, k - 1);\r\n        }\r\n        // or we can simply write this instead of the above 3, it will work the same\r\n//     if (a.charAt(i - 1) == c.charAt(k - 1) || b.charAt(j - 1) == c.charAt(k - 1)) {\r\n//          return dp[i][j] = helper(a, b, c, i - 1, j, k - 1) || helper(a, b, c, i, j - 1, k - 1);\r\n//     }\r\n        // if none are matching => we are on the wrong path return or backtrack\r\n        return dp[i][j] = false;\r\n    }",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1651047107890",
		"__v": 0
	},
	{
		"_id": "62690b2ec1a00b6c7ccf8e38",
		"title": "Longest Increasing Subsequence",
		"postLinkTitle": "longest-increasing-subsequence",
		"desc": "// There are two ways to solve this problem using DP\r\n\r\n//1. call helper function for possible j value for which currElem < arr[j] or viceverse accd. to the code\r\n\r\nclass Solution {\r\n    //Function to find length of longest increasing subsequence.\r\n    static int[] dp;\r\n    static int longestSubsequence(int size, int a[]){\r\n        dp = new int[size+1];\r\n        Arrays.fill(dp,-1);\r\n        helper(a,size);\r\n        int ans = 0;\r\n        for(int ele : dp) ans = Math.max(ans, ele);\r\n        return ans;\r\n    }\r\n    static int helper(int[] arr, int i){\r\n        if(i == 0){\r\n            return 0;\r\n        }\r\n        if(dp[i] != -1) return dp[i];\r\n        int ans = 0;\r\n        for(int j = 1;j<i;j++){\r\n            if(arr[i-1] > arr[j-1]){\r\n                ans = Math.max(ans, helper(arr,j));\r\n            }\r\n        }\r\n       // called to get ans if currElem is not included in the subsequence\r\n        helper(arr,i-1);\r\n        return dp[i] = 1 + ans;\r\n    }\r\n} \r\n\r\n\r\n// 2. If we closely observe the problem then we can convert this problem to the Longest Common Subsequence Problem. \r\n// Firstly we will create another array of unique elements of the original array and sort it. \r\n// Now the longest increasing subsequence of our array must be present as a subsequence in our sorted array. \r\n\r\nclass Solution {\r\n    //Function to find length of longest increasing subsequence.\r\n    static int longestSubsequence(int n, int arr[]){\r\n        SortedSet<Integer> hs = new TreeSet<Integer>();\r\n        // Storing and Sorting unique elements.\r\n        for (int i = 0; i < n; i++) hs.add(arr[i]);\r\n        int lis[] = new int[hs.size()];\r\n        int k = 0;\r\n        // Storing all the unique values in a sorted manner.\r\n        for (int val : hs) lis[k++] = val;\r\n\r\n        int m = k, i, j;\r\n        int dp[][] = new int[m + 1][n + 1];\r\n \r\n        // Finding the Longest Common Subsequence of the two arrays\r\n        for (i = 1; i < m + 1; i++) {\r\n            for (j = 1; j < n + 1; j++) {\r\n                if (arr[j - 1] == lis[i - 1]) dp[i][j] = 1 + dp[i - 1][j - 1];\r\n                else dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\r\n            }\r\n        }\r\n        return dp[m][n];\r\n    }\r\n} ",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1651051310850",
		"__v": 0
	},
	{
		"_id": "626e16cd6c7856ff8c09025c",
		"title": "Largest Permutation with Atmost K swaps",
		"postLinkTitle": "largest-permutation-with-atmost-k-swaps",
		"desc": "// Given an integer array A of size N consisting of unique integers from 1 to N. You can swap any two integers at most k times.\r\n// Return the largest lexicographical value array that can be created by executing at most k swaps.\r\n\r\npublic class Solution {\r\n    public int[] solve(int[] A, int B) {\r\n        int n = A.length;\r\n        int[] pos = new int[n+1];\r\n        //storing the pos of every elmnt in A\r\n        for(int i=0;i<n;i++) pos[A[i]] = i;\r\n\r\n        for(int i=0;i<A.length && B > 0;i++){\r\n            // current is in its correct pos\r\n            if(A[i] == n-i) continue;\r\n\r\n            // else swap it with the correct element\r\n            // update positions in pos array\r\n            int temp = pos[n-i];\r\n            pos[A[i]] = pos[n-i];\r\n            pos[n-i] = i;\r\n\r\n            //swap\r\n            swap(A,i,temp);\r\n            B--;\r\n        }\r\n        return A;\r\n    }\r\n    public void swap(int[] arr,int a, int b){\r\n        int temp = arr[a];\r\n        arr[a] = arr[b];\r\n        arr[b] = temp;\r\n    }\r\n}\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1651381965228",
		"__v": 0
	},
	{
		"_id": "6270be33bf2702e79c164c7b",
		"title": "Disjoint Intervels - Greedy",
		"postLinkTitle": "disjoint-intervels-greedy",
		"desc": "// Given a set of N intervals denoted by 2D array A of size N x 2, \r\n// the task is to find the length of the maximal set of mutually disjoint intervals. \r\n// Two intervals [x, y] & [p, q] are said to be disjoint if they do not have any point in common.\r\n// Return an integer denoting the length of the maximal set of mutually disjoint intervals.\r\n\r\n//Eg : A = [ [1, 4], [2, 3], [4, 6], [8, 9] ] => 3 ( [[2, 3], [4, 6], [8, 9]] )\r\n\r\npublic class Solution {\r\n    public int solve(int[][] A) {\r\n        // sort the matrix w.r.t end points in ascending order\r\n        Arrays.sort(A, new Comparator<int[]>(){\r\n            public int compare(int[] a, int[] b){\r\n                return a[1] - b[1];\r\n            }\r\n        });\r\n   \r\n        // the 1st set is always included\r\n        int prevRightEnd = A[0][1], cnt = 1;\r\n        // sysout(prev) -> for printing\r\n\r\n        for(int i=1;i<A.length;i++){\r\n            int curLeftEnd = A[i][0];\r\n            int curRightEnd = A[i][1];\r\n            // curr left > prev right => both sets are disjoint Eg: prev-(1,2) cur-(3,4)\r\n            if(prevRightEnd < curLeftEnd){\r\n                cnt++;\r\n                //update the prev to cur\r\n                prevRightEnd = curRightEnd;\r\n                //sysout(prev)\r\n            }\r\n        }\r\n        return cnt;\r\n    }\r\n}\r\n",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1651555891527",
		"__v": 0
	},
	{
		"_id": "6273548c66af037e91c5bc0d",
		"title": "DBMS Interview Prep",
		"postLinkTitle": "dbms-interview-prep",
		"desc": "https://www.interviewbit.com/sql-interview-questions/\r\nhttps://www.geeksforgeeks.org/sql-interview-questions/\r\n\r\nWhat is Database?\r\nA database is an organized collection of data, stored and retrieved digitally from a remote or local computer system.\r\n\r\nWhat is DBMS?\r\nDBMS stands for Database Management System. DBMS is a system software responsible for the creation, retrieval, updating, and management of the database. It ensures that our data is consistent, organized, and easily accessible by serving as an interface between the database and its end-users or application software.\r\n\r\nWhat is RDBMS? How is it different from DBMS?\r\nRDBMS stands for Relational Database Management System. The key difference here, compared to DBMS, is that RDBMS stores data in the form of a collection of tables, and relations can be defined between the common fields of these tables. Most modern database management systems like MySQL, Microsoft SQL Server, and Oracle are based on RDBMS.\r\n\r\n4. What is SQL?\r\nSQL stands for Structured Query Language. It is the standard language for relational database management systems. It is especially useful in handling organized data comprised of entities (variables) and relations between different entities of the data.\r\n\r\nWhat is a Primary Key?\r\nThe PRIMARY KEY constraint uniquely identifies each row in a table. It must contain UNIQUE values and has an implicit NOT NULL constraint.\r\nA table in SQL is strictly restricted to having one and only one primary key, which is comprised of single or multiple fields (columns).\r\n\r\nWhat is a UNIQUE constraint?\r\nA UNIQUE constraint ensures that all values in a column are different. This provides uniqueness for the column(s) and helps identify each row uniquely. Unlike the primary key, there can be multiple unique constraints defined per table. The code syntax for UNIQUE is quite similar to that of PRIMARY KEY and can be used interchangeably.\r\n\r\nWhat is a Foreign Key?\r\nA FOREIGN KEY comprises of single or collection of fields in a table that essentially refers to the PRIMARY KEY in another table. Foreign key constraint ensures referential integrity in the relation between two tables.\r\nThe table with the foreign key constraint is labelled as the child table, and the table containing the candidate key is labelled as the referenced or parent table.\r\n\r\nWhat is a Join? List its different types.\r\nThe SQL Join clause is used to combine records (rows) from two or more tables in a SQL database based on a related column between the two. There are four different types of JOINs in SQL:\r\n\r\n(INNER) JOIN: Retrieves records that have matching values in both tables involved in the join. This is the widely used join for queries.\r\nLEFT (OUTER) JOIN: Retrieves all the records/rows from the left and the matched records/rows from the right table.\r\nRIGHT (OUTER) JOIN: Retrieves all the records/rows from the right and the matched records/rows from the left table.\r\nFULL (OUTER) JOIN: Retrieves all the records where there is a match in either the left or right table.\r\n\r\nWhat is a Self-Join?\r\nA self JOIN is a case of regular join where a table is joined to itself based on some relation between its own column(s). Self-join uses the INNER JOIN or LEFT JOIN clause and a table alias is used to assign different names to the table within the query.\r\n\r\nWhat is a Cross-Join?\r\nCross join can be defined as a cartesian product of the two tables included in the join. The table after joining contains the same number of rows as in the cross-product of the number of rows in the two tables. If a WHERE clause is used in cross join then the query will work like an INNER JOIN.\r\n\r\nWhat are Entities and Relationships?\r\nEntity: An entity can be a real-world object, either tangible or intangible, that can be easily identifiable. For example, in a college database, students, professors, workers, departments, and projects can be referred to as entities. Each entity has some associated properties that provide it with an identity.\r\n\r\nRelationships: Relations or links between entities that have something to do with each other. For example - The employee's table in a company's database can be associated with the salary table in the same database.\r\n\r\nWhat is an Alias in SQL?\r\nAn alias is a feature of SQL that is supported by most, if not all, RDBMSs. It is a temporary name assigned to the table or table column for the purpose of a particular SQL query.\r\n\r\nWhat is a View?\r\nA view in SQL is a virtual table based on the result-set of an SQL statement. A view contains rows and columns, just like a real table. The fields in a view are fields from one or more real tables in the database.\r\n\r\nWhat is Normalization?\r\nNormalization represents the way of organizing structured data in the database efficiently. It includes the creation of tables, establishing relationships between them, and defining rules for those relationships. Inconsistency and redundancy can be kept in check based on these rules, hence, adding flexibility to the database.\r\n\r\nWhat is Denormalization?\r\nDenormalization is the inverse process of normalization, where the normalized schema is converted into a schema that has redundant information.\r\n\r\nWhat are ACID properties?\r\nACID stands for Atomicity, Consistency, Isolation, Durability. They are database transaction properties which are used for guaranteeing data validity in case of errors and failures.\r\n\r\nAtomicity: This property ensures that the transaction is completed in an all-or-nothing way.\r\nConsistency: This ensures that updates made to the database are valid and follow rules and restrictions.\r\nIsolation: This property ensures the integrity of transactions that are visible to all other transactions.\r\nDurability: This property ensures that the committed transactions are stored permanently in the database.\r\n\r\nWhat are the advantages of DBMS over traditional file-based systems? \r\n\r\nDatabase management systems were developed to handle the following difficulties of typical Fille-processing systems supported by conventional operating systems. \r\n1. Data redundancy and inconsistency \r\n2. Difficulty in accessing data \r\n3. Data isolation  multiple files and formats \r\n4. Integrity problems \r\n5. Atomicity of updates \r\n6. Concurrent access by multiple users \r\n7. Security problems \r\n \r\n\r\nWhat are super, primary, candidate, and foreign keys? \r\nA super key is a set of attributes of a relation schema upon which all attributes of the schema are functionally dependent. No two rows can have the same value of super key attributes. \r\nA Candidate key is a minimal superkey, i.e., no proper subset of Candidate key attributes can be a superkey. \r\nA Primary Key is one of the candidate keys. One of the candidate keys is selected as the most important and becomes the primary key. There cannot be more than one primary key in a table.\r\nA Foreign key is a field (or collection of fields) in one table that uniquely identifies a row of another table. \r\n\r\nWhat is the difference between primary key and unique constraints? \r\nThe primary key cannot have a NULL value, the unique constraints can have NULL values. There is only one primary key in a table, but there can be multiple unique constraints. \r\n\r\nWhat is database normalization? \r\nIt is a process of analyzing the given relation schemas based on their functional dependencies and primary keys to achieve the following desirable properties: \r\n1. Minimizing Redundancy \r\n2. Minimizing the Insertion, Deletion, And Update Anomalies Relation schemas that do not meet the properties are decomposed into smaller relation schemas that could meet desirable properties.\r\n\r\nTypes of SQL Commands\r\nThere are five types of SQL commands: DDL, DML, DCL, TCL\r\n1. Data Definition Language (DDL) - changes the structure of the table like creating a table, deleting a table, altering a table, etc.\r\nEg: CREATE, ALTER, DROP & TRUNCATE\r\n2. Data Manipulation Language(DML) - commands are used to modify the database. It is responsible for all forms of changes in the database.\r\nEg: INSERT, UPDATE, DELETE\r\n3. Data Control Language(DCL) - commands are used to grant and take back authority from any database user.\r\nEg: Grant, Revoke\r\n4. Transaction Control Language(TCL) - commands can only use with DML commands like INSERT, DELETE and UPDATE only. These operations are automatically committed in the database that's why they cannot be used while creating tables or dropping them.\r\nEg: COMMIT, ROLLBACK, SAVEPOINT",
		"author": "621a1d7a3675ab55c568e0ab",
		"date": "1651725452215",
		"__v": 0
	}
]
